{
  "id": "Threads_Sheet1_1757928320233_95l47_1757934836047",
  "website": "Threads",
  "task": {
    "id": "Sheet1_1757928320233_95l47",
    "description": "M002",
    "objective": "Rapidly Click Like Buttons",
    "expectedResult": "Click like buttons on all visible threads in rapid succession (within 5 seconds)",
    "difficulty": ".thread-action[data-action='like']",
    "category": 3,
    "tags": [
      "10 seconds"
    ],
    "notes": "Yes"
  },
  "websiteInfo": {
    "name": "Threads",
    "htmlFiles": [
      "index.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the threads feed to be visible\n    await page.waitForSelector('#threads-feed', { timeout: 5000 });\n\n    // Wait for at least one thread like button to appear\n    await page.waitForSelector(\".thread-action[data-action='like']\", { timeout: 5000 });\n\n    // Get all visible like buttons in the threads feed\n    const likeButtons = await page.$$eval(\n      \"#threads-feed .thread-action[data-action='like']\",\n      (btns) =>\n        btns\n          .filter(\n            (btn) =>\n              btn.offsetParent !== null && // visible in DOM\n              !btn.classList.contains('liked') && // not already liked (if such a class exists)\n              !btn.disabled // not disabled\n          )\n          .map((btn) => {\n            // Try to get a unique selector for each button\n            return {\n              xpath: btn ? window.__pw_getXPath(btn) : null\n            };\n          })\n    );\n\n    // Fallback for XPath helper if not present\n    await page.addInitScript(() => {\n      window.__pw_getXPath = function(element) {\n        if (!element) return '';\n        if (element.id) return `//*[@id=\"${element.id}\"]`;\n        const parts = [];\n        while (element && element.nodeType === Node.ELEMENT_NODE) {\n          let nbOfPreviousSiblings = 0;\n          let hasNextSiblings = false;\n          let sibling = element.previousSibling;\n          while (sibling) {\n            if (sibling.nodeType !== Node.DOCUMENT_TYPE_NODE && sibling.nodeName === element.nodeName) nbOfPreviousSiblings++;\n            sibling = sibling.previousSibling;\n          }\n          sibling = element.nextSibling;\n          while (sibling) {\n            if (sibling.nodeName === element.nodeName) hasNextSiblings = true;\n            sibling = sibling.nextSibling;\n          }\n          const prefix = element.prefix ? element.prefix + \":\" : \"\";\n          const nth = nbOfPreviousSiblings || hasNextSiblings ? `[${nbOfPreviousSiblings + 1}]` : \"\";\n          parts.push(prefix + element.localName + nth);\n          element = element.parentNode;\n        }\n        return \"/\" + parts.reverse().join(\"/\");\n      };\n    });\n\n    // Re-fetch like buttons with XPath after helper is injected\n    const likeButtonHandles = await page.$$(\n      \"#threads-feed .thread-action[data-action='like']\"\n    );\n\n    // Filter only visible and not already liked\n    const visibleLikeButtonHandles = [];\n    for (const handle of likeButtonHandles) {\n      const isVisible = await handle.evaluate(\n        (btn) => btn.offsetParent !== null && !btn.disabled\n      );\n      const isLiked = await handle.evaluate(\n        (btn) => btn.classList.contains('liked')\n      );\n      if (isVisible && !isLiked) {\n        visibleLikeButtonHandles.push(handle);\n      }\n    }\n\n    // Click all visible like buttons in rapid succession (within 5 seconds)\n    const likeClickPromises = [];\n    const likeButtonCount = visibleLikeButtonHandles.length;\n    for (const handle of visibleLikeButtonHandles) {\n      likeClickPromises.push(handle.click({ delay: 50 }));\n    }\n    // Wait for all clicks to finish, but timeout after 5 seconds\n    await Promise.race([\n      Promise.all(likeClickPromises),\n      new Promise((resolve) => setTimeout(resolve, 5000))\n    ]);\n\n    // Wait a moment for UI to update\n    await page.waitForTimeout(500);\n\n    // Take screenshot after liking\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_likes_clicked.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_likes_clicked.png'));\n\n    // Extract data: count of liked buttons after clicking\n    const likedCount = await page.$$eval(\n      \"#threads-feed .thread-action[data-action='like'].liked\",\n      (btns) => btns.length\n    );\n\n    // Extract thread IDs or content that were liked for verification\n    const likedThreads = await page.$$eval(\n      \"#threads-feed .thread-item\",\n      (threads) => {\n        return Array.from(threads).map(thread => {\n          const liked = thread.querySelector(\".thread-action[data-action='like'].liked\") !== null;\n          const id = thread.getAttribute('data-thread-id') || null;\n          const content = thread.querySelector('.thread-content')?.innerText || '';\n          return liked ? { id, content } : null;\n        }).filter(Boolean);\n      }\n    );\n\n    return {\n      success: true,\n      action: `Clicked like buttons on all visible threads in rapid succession (${likeButtonCount} attempted, ${likedCount} now liked)`,\n      extractedData: {\n        likeButtonsAttempted: likeButtonCount,\n        likedCountAfter: likedCount,\n        likedThreads\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 21128,
      "timestamp": "2025-09-15T11:13:56.047Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file and wait for page load\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the threads feed to be visible\n    await page.waitForSelector('div#threads-feed', { timeout: 5000 });\n\n    // Wait for at least one thread item to appear (use a class-based selector as an alternative strategy)\n    await page.waitForSelector(\".thread-item, .thread-actions, .thread-username\", { timeout: 5000 });\n\n    // Find ALL visible like buttons for threads using XPath to avoid previous failures and cover alternative DOM structures.\n    // This selector targets any button or element with a data-action attribute 'like' that is visible\n    const likeButtons = await page.$$('xpath=//*[contains(@class,\"thread-action\") and @data-action=\"like\" and not(contains(@class,\"liked\")) and not(ancestor-or-self::*[contains(@style,\"display: none\") or contains(@style,\"visibility: hidden\")])]');\n\n    // If the above finds nothing, try a second, different selector strategy (for robustness)\n    let buttonsToLike = likeButtons;\n    if (buttonsToLike.length === 0) {\n      buttonsToLike = await page.$$('button.thread-action[data-action=\"like\"]:not(.liked)');\n    }\n\n    // Filter only visible buttons (sometimes hidden with CSS, so check isVisible)\n    const visibleLikeButtons = [];\n    for (const btn of buttonsToLike) {\n      if (await btn.isVisible()) {\n        visibleLikeButtons.push(btn);\n      }\n    }\n\n    // Take screenshot before liking\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_likes.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_likes.png'));\n\n    // Click all visible like buttons in rapid succession (use Promise.all for speed)\n    // Pause only briefly (e.g., 100ms) between clicks to simulate \"rapid succession\" but avoid race conditions\n    const clickResults = [];\n    const clickPromises = [];\n    for (const btn of visibleLikeButtons) {\n      // Click and push result to clickResults\n      clickPromises.push(btn.click({ delay: 30 }).then(() => true).catch(() => false));\n      // Short delay to ensure UI updates register\n      await page.waitForTimeout(60);\n    }\n    // Await all clicks (should be fast, total < 5s)\n    const results = await Promise.all(clickPromises);\n\n    // Wait for the UI to reflect the likes (wait for at least one like button to have \"liked\" state)\n    // Try multiple selectors for \"liked\" state\n    await page.waitForSelector('.thread-action.liked, .thread-action[aria-pressed=\"true\"], .thread-action[data-liked=\"true\"]', { timeout: 3000 });\n\n    // Take screenshot after liking\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_likes.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_likes.png'));\n\n    // Extract information: how many like buttons were clicked and how many are now in a \"liked\" state\n    const likedNow = await page.$$eval(\n      '.thread-action.liked, .thread-action[aria-pressed=\"true\"], .thread-action[data-liked=\"true\"]',\n      nodes => nodes.length\n    );\n\n    return {\n      success: true,\n      action: `Clicked all visible thread like buttons in rapid succession (${visibleLikeButtons.length} attempted, ${results.filter(Boolean).length} succeeded, ${likedNow} now show as liked)`,\n      extractedData: {\n        attemptedLikes: visibleLikeButtons.length,\n        successfulClicks: results.filter(Boolean).length,\n        currentlyLikedButtons: likedNow\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 19366,
      "timestamp": "2025-09-15T11:14:17.175Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Wait for the threads feed to be visible and at least one thread to load\n    await page.waitForSelector('#threads-feed', { state: 'visible', timeout: 5000 });\n    // Give some buffer for dynamic content\n    await page.waitForTimeout(500);\n\n    // Find all visible \"like\" buttons using a selector strategy that is NOT just the original data-action attribute\n    // We'll use a combination: look for buttons within .thread-item containing a .fa-heart (FontAwesome) icon that are not already \"liked\"\n    // This is different from previous failed attempts\n\n    // Wait for at least one thread item with an actionable like button\n    await page.waitForSelector(\".thread-item .thread-action\", { timeout: 4000 });\n\n    // Get all visible like buttons that are not already \"liked\"\n    const likeButtons = await page.$$eval(\n      \".thread-item .thread-action\",\n      (elements) => {\n        // Find those with data-action='like' and not already liked\n        return elements\n          .filter(el => \n            el.getAttribute('data-action') === 'like' &&\n            // Additional check: not already liked (no 'liked' class or aria-pressed)\n            !el.classList.contains('liked') &&\n            el.offsetParent !== null // Visible\n          )\n          .map(el => ({\n            xpath: window.getComputedStyle(el).display !== 'none' ? el.getAttribute('data-thread-id') : null,\n            selector: el.getAttribute('data-thread-id')\n          }));\n      }\n    );\n\n    // As a fallback, if data-thread-id is not present, select by index\n\n    // Get all button elements that match the like icon and are visible\n    const visibleLikeHandles = await page.$$(\".thread-item .thread-action[data-action='like']:not(.liked)\");\n\n    // Take screenshot before clicking likes\n    const beforeLikesShot = path.join(screenshotsDir, 'step_2_before_likes.png');\n    await page.screenshot({ path: beforeLikesShot });\n    screenshots.push(beforeLikesShot);\n\n    // Click all like buttons in rapid succession (within 5 seconds)\n    // We'll use Promise.all with click, but stagger slightly to simulate rapid user clicks\n    let likedThreads = [];\n    const startTime = Date.now();\n    for (let i = 0; i < visibleLikeHandles.length; i++) {\n      // Scroll into view just in case\n      await visibleLikeHandles[i].scrollIntoViewIfNeeded();\n      await visibleLikeHandles[i].hover();\n      await visibleLikeHandles[i].click({ delay: 50 });\n      // Try to extract thread id for result data\n      const threadId = await visibleLikeHandles[i].getAttribute('data-thread-id');\n      likedThreads.push(threadId || i);\n      // Small delay to simulate rapid but not simultaneous clicks\n      await page.waitForTimeout(150);\n      // Check elapsed time to not exceed 5 seconds\n      if (Date.now() - startTime > 4900) break;\n    }\n\n    // Wait for UI to update (like icons should change state)\n    await page.waitForTimeout(800);\n\n    // Take screenshot after clicking likes\n    const afterLikesShot = path.join(screenshotsDir, 'step_3_after_likes.png');\n    await page.screenshot({ path: afterLikesShot });\n    screenshots.push(afterLikesShot);\n\n    // Extract number of liked threads by counting .thread-action[data-action='like'].liked\n    const likedCount = await page.$$eval(\n      \".thread-item .thread-action[data-action='like'].liked\",\n      els => els.length\n    );\n\n    return {\n      success: true,\n      action: `Clicked like buttons on all visible threads in rapid succession (${likedThreads.length} likes attempted, ${likedCount} confirmed).`,\n      extractedData: {\n        likedThreads: likedThreads,\n        likedCount: likedCount\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 26530,
      "timestamp": "2025-09-15T11:14:36.541Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 67024,
  "timestamp": "2025-09-15T11:13:56.047Z",
  "savedAt": "2025-09-15T11:15:03.071Z",
  "version": "1.0"
}