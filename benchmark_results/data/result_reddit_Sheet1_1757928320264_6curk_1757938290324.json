{
  "id": "reddit_Sheet1_1757928320264_6curk_1757938290324",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320264_6curk",
    "description": 8,
    "objective": "Regular",
    "expectedResult": "Save first post",
    "difficulty": "Easy",
    "category": "Click save button on first post and verify it's marked as saved",
    "tags": [
      ".post:first-child .post-action.saved"
    ],
    "notes": "toggleSavePost() saveDataToStorage()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the posts container to load (main feed)\n    // Try to find the first post by a likely selector or structure\n    // We'll use a generic approach: find the first post card/article/div with post content\n\n    // Wait for any post to appear (look for post title)\n    await page.waitForSelector('text=\"Just built my first React app! What do you think?\"', { timeout: 5000 });\n\n    // Find the post container for the first post (by title text)\n    const postTitle = await page.$('text=\"Just built my first React app! What do you think?\"');\n    if (!postTitle) throw new Error('First post title not found');\n\n    // Ascend to the post container (likely a parent div or article)\n    const postContainer = await postTitle.evaluateHandle(node => {\n      // Go up to the post container (assume it's 2-3 parents up)\n      let el = node;\n      for (let i = 0; i < 3; i++) {\n        if (el.parentElement) el = el.parentElement;\n      }\n      return el;\n    });\n\n    // Within the post container, look for the Save button\n    // Try to find a button with text 'Save' or an icon with a tooltip\n    // Try several strategies\n\n    // 1. Try to find a 'Save' button inside the post container\n    let saveButton = await postContainer.$('button:has-text(\"Save\")');\n    if (!saveButton) {\n      // 2. Try to find a button with a bookmark icon (FontAwesome or similar)\n      saveButton = await postContainer.$('button[aria-label*=\"Save\"], button[title*=\"Save\"], button:has(i.fa-bookmark)');\n    }\n    if (!saveButton) {\n      // 3. Try to find any button with a bookmark svg/icon\n      saveButton = await postContainer.$('button:has(svg[aria-label*=\"Save\"]), button:has(svg[title*=\"Save\"])');\n    }\n    if (!saveButton) {\n      // 4. Try to find any button with 'bookmark' in class\n      saveButton = await postContainer.$('button[class*=\"bookmark\"]');\n    }\n    if (!saveButton) throw new Error('Save button not found in first post');\n\n    // Take screenshot before saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_save.png'));\n\n    // Click the Save button\n    await saveButton.click();\n\n    // Wait for the button or post to reflect the \"saved\" state\n    // This could be a class change, icon change, or text change (\"Saved\")\n    // Wait for either the button text to become \"Saved\" or a class to indicate saved state\n\n    let savedStateDetected = false;\n    for (let i = 0; i < 10; i++) {\n      // Try to find the button again (it may have changed)\n      let savedBtn = await postContainer.$('button:has-text(\"Saved\")');\n      if (savedBtn) {\n        savedStateDetected = true;\n        break;\n      }\n      // Try to detect a class or aria-pressed\n      let btn = await postContainer.$('button');\n      if (btn) {\n        const className = await btn.getAttribute('class');\n        const ariaPressed = await btn.getAttribute('aria-pressed');\n        if ((className && className.includes('saved')) || ariaPressed === 'true') {\n          savedStateDetected = true;\n          break;\n        }\n      }\n      await page.waitForTimeout(300);\n    }\n\n    // Take screenshot after saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_save.png'));\n\n    // Extract verification data: check if the first post is marked as saved\n    let savedButtonText = '';\n    let savedButtonClass = '';\n    let savedButtonAriaPressed = '';\n    let savedButtonExists = false;\n\n    // Try to find the saved button again\n    const savedBtn = await postContainer.$('button:has-text(\"Saved\")');\n    if (savedBtn) {\n      savedButtonText = await savedBtn.innerText();\n      savedButtonClass = await savedBtn.getAttribute('class');\n      savedButtonAriaPressed = await savedBtn.getAttribute('aria-pressed');\n      savedButtonExists = true;\n    } else if (saveButton) {\n      savedButtonText = await saveButton.innerText();\n      savedButtonClass = await saveButton.getAttribute('class');\n      savedButtonAriaPressed = await saveButton.getAttribute('aria-pressed');\n      savedButtonExists = false;\n    }\n\n    return {\n      success: savedStateDetected,\n      action: \"Clicked save button on first post and verified it is marked as saved\",\n      extractedData: {\n        savedButtonText,\n        savedButtonClass,\n        savedButtonAriaPressed,\n        savedButtonExists\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 22717,
      "timestamp": "2025-09-15T12:11:30.324Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for main feed to load by waiting for post title (use XPath for robustness)\n    await page.waitForSelector('xpath=//div[contains(@class,\"post-title\") or //h2[contains(text(),\"React app\")]]');\n\n    // Find the first post container using a generic post class or the first .post element\n    // Try common post area, fallback to header text\n    let firstPost;\n    try {\n      // Try finding post with a known class\n      firstPost = await page.$('div.post, article.post, div[data-testid=\"post-container\"], xpath=//div[contains(@class,\"post\")][1]');\n      if (!firstPost) {\n        // Fallback: find by heading text\n        firstPost = await page.$('xpath=//h2[contains(text(),\"React app\")]/ancestor::div[contains(@class,\"post\")][1]');\n      }\n    } catch { /* fallback handled below */ }\n\n    if (!firstPost) {\n      // As a last resort, just select the first h2 in the feed area\n      firstPost = await page.$('main h2');\n    }\n\n    if (!firstPost) throw new Error(\"Could not locate the first post\");\n\n    // Within the first post, locate the Save button\n    // Save buttons may have text 'Save' or a bookmark icon, try multiple selectors\n    let saveButton = await firstPost.$('button:has-text(\"Save\")');\n    if (!saveButton) {\n      saveButton = await firstPost.$('button[aria-label*=\"save\"], button[title*=\"Save\"], button:has(i.fa-bookmark), xpath=.//button[contains(., \"Save\")]');\n    }\n\n    if (!saveButton) {\n      // Fallback: search globally for the first Save button near the first post title\n      const postTitle = await firstPost.$('h2');\n      if (postTitle) {\n        const titleText = await postTitle.textContent();\n        // Use XPath to find Save button near this title\n        saveButton = await page.$(`xpath=//h2[contains(., \"${titleText}\")]/ancestor::div[contains(@class,\"post\")][1]//button[contains(.,\"Save\")]`);\n      }\n    }\n\n    if (!saveButton) throw new Error(\"Could not locate the Save button on the first post\");\n\n    // Take screenshot before clicking Save\n    await firstPost.screenshot({ path: path.join(screenshotsDir, 'step_2_before_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_save.png'));\n\n    // Click the Save button\n    await saveButton.click();\n\n    // Wait for the Save button to change state (e.g. text changes to 'Saved' or icon changes)\n    // Try to detect the changed state (wait up to 3 seconds)\n    let savedBtn;\n    try {\n      await page.waitForTimeout(400); // small pause for DOM update\n      savedBtn = await firstPost.waitForSelector('button:has-text(\"Saved\"), button.saved, button[aria-pressed=\"true\"], button[aria-label*=\"saved\"]', { timeout: 3000 });\n    } catch { /* If not, fallback below */ }\n\n    // Take screenshot after clicking Save\n    await firstPost.screenshot({ path: path.join(screenshotsDir, 'step_3_after_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_save.png'));\n\n    // Extract state for verification\n    let saveButtonText = '';\n    if (savedBtn) {\n      saveButtonText = await savedBtn.textContent();\n    } else {\n      // If state button not found, try to get the original save button's text (may have changed)\n      saveButtonText = await saveButton.textContent();\n    }\n\n    const isSaved = saveButtonText && saveButtonText.toLowerCase().includes('saved');\n    \n    return {\n      success: isSaved,\n      action: \"Clicked the Save button on the first post and verified it is marked as saved.\",\n      extractedData: {\n        saveButtonText: saveButtonText ? saveButtonText.trim() : null,\n        isSaved\n      },\n      screenshots,\n      error: isSaved ? null : 'Save button did not visually change to Saved'\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 22303,
      "timestamp": "2025-09-15T12:11:53.041Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Initial screenshot of loaded Reddit page\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for main feed of posts (look for a post's distinctive title)\n    await page.waitForSelector('h2, .post-title, .feed-post, [data-testid=\"post-container\"]', { timeout: 8000 });\n\n    // Find the first post's container using a generic approach: look for the first h2 inside the feed area\n    // Try to find the first post title element (try h2, then fallback to text)\n    let firstPostTitleElement = await page.$('main h2');\n    if (!firstPostTitleElement) {\n      // Try to find by text content fallback (using the sample post)\n      firstPostTitleElement = await page.locator('text=Just built my first React app! What do you think?').first();\n    }\n    if (!firstPostTitleElement) {\n      throw new Error('Could not locate first post title');\n    }\n\n    // Get the parent post container from the title element (walk up the DOM)\n    // Try to find the closest post container (usually an article, div with specific class, or similar)\n    let postContainer = await firstPostTitleElement.evaluateHandle(el => {\n      let curr = el;\n      while (curr && !curr.classList.contains('post') && curr.tagName.toLowerCase() !== 'article') {\n        curr = curr.parentElement;\n      }\n      return curr;\n    });\n    // If not found, fallback to parentNode\n    if (!postContainer) {\n      postContainer = await firstPostTitleElement.evaluateHandle(el => el.parentElement);\n    }\n\n    // Within the post container, find the \"Save\" button - try by button text content or aria-label\n    // Since the HTML is not explicit, use a flexible selector for the first \"Save\" button within the post\n    let saveButton = null;\n    // Try button with text \"Save\"\n    saveButton = await postContainer.asElement().$('button:has-text(\"Save\")');\n    if (!saveButton) {\n      // Try aria-label\n      saveButton = await postContainer.asElement().$('button[aria-label*=\"save\"], button[title*=\"Save\"]');\n    }\n    if (!saveButton) {\n      // Try a generic button (e.g., nth-child if the post has action buttons)\n      const actionBtns = await postContainer.asElement().$$('button');\n      for (const btn of actionBtns) {\n        const btnText = await btn.textContent();\n        if (btnText && btnText.toLowerCase().includes('save')) {\n          saveButton = btn;\n          break;\n        }\n      }\n    }\n    if (!saveButton) {\n      // Try global search as last fallback (can be risky!)\n      saveButton = await page.$('button:has-text(\"Save\")');\n    }\n    if (!saveButton) {\n      throw new Error('Could not find the Save button for the first post');\n    }\n\n    // Take screenshot before saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_save.png'));\n\n    // Click the save button\n    await saveButton.click();\n\n    // Wait for the button to change state to \"Saved\" (text content, or aria-pressed, or some visual indicator)\n    // Use a polling approach for up to 4s\n    let savedState = false;\n    let savedButtonText = '';\n    for (let i = 0; i < 10; ++i) {\n      // Re-locate the save button (in case DOM changed)\n      let btn = await postContainer.asElement().$('button:has-text(\"Saved\")');\n      if (!btn) {\n        // Try by text content\n        const actionBtns2 = await postContainer.asElement().$$('button');\n        for (const b of actionBtns2) {\n          const txt = await b.textContent();\n          if (txt && txt.trim().toLowerCase().includes('saved')) {\n            btn = b;\n            break;\n          }\n        }\n      }\n      if (btn) {\n        savedState = true;\n        savedButtonText = await btn.textContent();\n        break;\n      }\n      // Wait a bit and retry\n      await page.waitForTimeout(400);\n    }\n\n    // Screenshot after saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_save.png'));\n\n    // Extract the post title and saved state as verification\n    const postTitle = await firstPostTitleElement.textContent();\n    // Fallback: if not found, try extracting any \"Saved\" button text in the post container\n    if (!savedState) {\n      // Try to extract any button that now says \"Saved\"\n      const actionBtns2 = await postContainer.asElement().$$('button');\n      for (const b of actionBtns2) {\n        const txt = await b.textContent();\n        if (txt && txt.trim().toLowerCase().includes('saved')) {\n          savedState = true;\n          savedButtonText = txt.trim();\n          break;\n        }\n      }\n    }\n\n    return {\n      success: savedState,\n      action: \"Clicked the Save button on the first post and verified it is now marked as saved.\",\n      extractedData: {\n        firstPostTitle: postTitle ? postTitle.trim() : null,\n        saveButtonTextAfter: savedButtonText ? savedButtonText.trim() : null,\n        isSaved: savedState\n      },\n      screenshots,\n      error: savedState ? null : \"Save state could not be verified.\"\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 26927,
      "timestamp": "2025-09-15T12:12:15.344Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 71947,
  "timestamp": "2025-09-15T12:11:30.324Z",
  "savedAt": "2025-09-15T12:12:42.271Z",
  "version": "1.0"
}