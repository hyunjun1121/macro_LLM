{
  "id": "reddit_Sheet1_1757928320272_lpt8s_1757938546704",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320272_lpt8s",
    "description": 12,
    "objective": "Regular",
    "expectedResult": "Test keyboard navigation",
    "difficulty": "Medium",
    "category": "Use Tab key to navigate through interactive elements and verify focus",
    "tags": [
      "focusable elements [tabindex] [role]"
    ],
    "notes": "setupKeyboardNavigation()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Focus on body to start tab navigation\n    await page.focus('body');\n\n    // Prepare to collect focus order and labels\n    const focusedElements = [];\n    const focusLabels = [];\n\n    // Helper to get a readable label for the currently focused element\n    async function getFocusedLabel() {\n      return await page.evaluate(() => {\n        const el = document.activeElement;\n        if (!el) return null;\n        // Try aria-label, placeholder, innerText, alt, value, id, class\n        let label = el.getAttribute('aria-label') ||\n                    el.getAttribute('placeholder') ||\n                    el.innerText ||\n                    el.getAttribute('alt') ||\n                    el.value ||\n                    el.id ||\n                    el.className ||\n                    el.tagName;\n        label = label && label.trim();\n        // For buttons, include text content\n        if (el.tagName === 'BUTTON' && el.innerText) {\n          label = el.innerText.trim();\n        }\n        // For select, include options\n        if (el.tagName === 'SELECT') {\n          label = 'Select: ' + (el.name || el.id || el.className || 'dropdown');\n        }\n        return {\n          tag: el.tagName,\n          label,\n          id: el.id,\n          class: el.className,\n          name: el.getAttribute('name'),\n          ariaLabel: el.getAttribute('aria-label'),\n          placeholder: el.getAttribute('placeholder')\n        };\n      });\n    }\n\n    // We'll tab through up to 12 interactive elements (should be enough for main nav)\n    let tabCount = 0;\n    let maxTabs = 12;\n    let lastFocus = null;\n\n    // Focus should start at body, so first Tab will go to first tabbable element\n    while (tabCount < maxTabs) {\n      await page.keyboard.press('Tab');\n      await page.waitForTimeout(200); // Give time for focus to move\n\n      const labelInfo = await getFocusedLabel();\n      // If focus cycles back to the first, break\n      if (tabCount > 0 && lastFocus && labelInfo && labelInfo.label === lastFocus.label && labelInfo.tag === lastFocus.tag) {\n        break;\n      }\n      if (labelInfo) {\n        focusedElements.push(labelInfo);\n        focusLabels.push(labelInfo.label);\n        lastFocus = labelInfo;\n      }\n      // Take screenshot at each step\n      await page.screenshot({ path: path.join(screenshotsDir, `step_2_tab_${tabCount + 1}.png`) });\n      screenshots.push(path.join(screenshotsDir, `step_2_tab_${tabCount + 1}.png`));\n      tabCount++;\n    }\n\n    // Extracted data: the order of focusable elements and their labels\n    const extractedData = {\n      focusOrder: focusedElements\n    };\n\n    return {\n      success: true,\n      action: \"Tested keyboard Tab navigation through interactive elements and verified focus order and labels.\",\n      extractedData,\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 27295,
      "timestamp": "2025-09-15T12:15:46.704Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Focus the document body to ensure Tab navigation starts from the top\n    await page.focus('body');\n\n    // Wait for the header and the search input to be visible\n    await page.waitForSelector('header.header');\n    await page.waitForSelector('input[placeholder=\"Search Reddit\"]');\n\n    // Start tabbing through focusable elements, record focus order\n    const focusedElements = [];\n    // Helper to get the currently focused element's description\n    async function getFocusedDescription() {\n      return await page.evaluate(() => {\n        const el = document.activeElement;\n        if (!el) return null;\n        let desc = '';\n        if (el.id) desc += `#${el.id} `;\n        if (el.className) desc += `.${el.className} `;\n        desc += `<${el.tagName.toLowerCase()}>`;\n        if (el.getAttribute('aria-label')) desc += ` [aria-label=\"${el.getAttribute('aria-label')}\"]`;\n        if (el.placeholder) desc += ` [placeholder=\"${el.placeholder}\"]`;\n        if (el.type) desc += ` [type=\"${el.type}\"]`;\n        if (el.textContent && el.textContent.trim()) desc += ` [text=\"${el.textContent.trim().replace(/\\s+/g, ' ')}\"]`;\n        return desc.trim();\n      });\n    }\n\n    // Wait for focusable elements to be ready\n    await page.waitForSelector('button.theme-toggle-btn');\n    await page.waitForSelector('button.create-post-btn');\n    await page.waitForSelector('button.community-link');\n    await page.waitForSelector('input[placeholder=\"An interesting title\"]');\n    await page.waitForSelector('select#postCommunity');\n\n    // List of expected focusable selectors in order (approximate)\n    // We'll tab through up to 12 focusable elements\n    const tabSteps = 12;\n\n    // Focus the first focusable element (should be search input)\n    // Some browsers may default to the first input, otherwise we Tab to get there\n    await page.keyboard.press('Tab');\n    for (let i = 0; i < tabSteps; i++) {\n      // Give time for focus to change\n      await page.waitForTimeout(150);\n      const desc = await getFocusedDescription();\n      focusedElements.push(desc);\n      // Take a screenshot at a few steps for verification\n      if (i === 0) {\n        await page.screenshot({ path: path.join(screenshotsDir, 'step_2_first_tab.png') });\n        screenshots.push(path.join(screenshotsDir, 'step_2_first_tab.png'));\n      }\n      if (i === 2) {\n        await page.screenshot({ path: path.join(screenshotsDir, 'step_3_third_tab.png') });\n        screenshots.push(path.join(screenshotsDir, 'step_3_third_tab.png'));\n      }\n      if (i === 5) {\n        await page.screenshot({ path: path.join(screenshotsDir, 'step_4_sixth_tab.png') });\n        screenshots.push(path.join(screenshotsDir, 'step_4_sixth_tab.png'));\n      }\n      // Move to the next element\n      await page.keyboard.press('Tab');\n    }\n\n    // Extract the sequence of focused element descriptions\n    const focusOrder = focusedElements.filter(v => !!v);\n\n    return {\n      success: true,\n      action: \"Tested keyboard Tab navigation. Tabbed through interactive elements and extracted focus order.\",\n      extractedData: {\n        focusOrder\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 24214,
      "timestamp": "2025-09-15T12:16:13.999Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Store screenshot paths\n    const screenshots = [];\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the page to render a visible landmark: header (role=\"banner\")\n    await page.waitForSelector('header[role=\"banner\"]', { state: 'visible' });\n\n    // Focus body to start keyboard navigation\n    await page.focus('body');\n\n    // Prepare to collect focus sequence for interactive elements\n    const focusOrder = [];\n\n    // Utility to get the currently focused element's descriptor\n    async function getFocusedDescriptor() {\n      return await page.evaluate(() => {\n        const el = document.activeElement;\n        if (!el) return null;\n        let tag = el.tagName;\n        let type = el.type || '';\n        let name = el.name || '';\n        let id = el.id || '';\n        let aria = el.getAttribute('aria-label') || '';\n        let placeholder = el.placeholder || '';\n        let className = el.className || '';\n        return { tag, type, name, id, aria, placeholder, className };\n      });\n    }\n\n    // Focus the first tabbable element by pressing Tab (should be search input)\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    const firstFocus = await getFocusedDescriptor();\n    focusOrder.push(firstFocus);\n\n    // Tab to the next element (should be user menu or theme toggle, depending on tab order)\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    const secondFocus = await getFocusedDescriptor();\n    focusOrder.push(secondFocus);\n\n    // Tab to the next element\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    const thirdFocus = await getFocusedDescriptor();\n    focusOrder.push(thirdFocus);\n\n    // Tab to the next element\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    const fourthFocus = await getFocusedDescriptor();\n    focusOrder.push(fourthFocus);\n\n    // Tab to the next element (should reach one of the sidebar community links)\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    const fifthFocus = await getFocusedDescriptor();\n    focusOrder.push(fifthFocus);\n\n    // Take screenshot after tabbing through header and into sidebar\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_tab_navigation.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_tab_navigation.png'));\n\n    // For confirmation, extract the aria-labels or placeholders of all focused elements\n    const extractedData = {\n      focusSequence: focusOrder.map(f => ({\n        tag: f.tag,\n        id: f.id,\n        className: f.className,\n        aria: f.aria,\n        placeholder: f.placeholder\n      }))\n    };\n\n    // Check that at least one input, one button, and one community link are reached\n    const hasSearchInput = focusOrder.some(f => f.placeholder && f.placeholder.toLowerCase().includes('search'));\n    const hasCreateBtn = focusOrder.some(f => f.aria && f.aria.toLowerCase().includes('create a new post'));\n    const hasCommunityLink = focusOrder.some(f => f.aria && f.aria.toLowerCase().includes('visit programming community'));\n\n    // Final screenshot after several tabs\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_final_focus.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_final_focus.png'));\n\n    return {\n      success: hasSearchInput && hasCreateBtn && hasCommunityLink,\n      action: \"Tested keyboard navigation using Tab: verified focus moves across header, search, and sidebar community links.\",\n      extractedData,\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 16630,
      "timestamp": "2025-09-15T12:16:38.213Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 68139,
  "timestamp": "2025-09-15T12:15:46.704Z",
  "savedAt": "2025-09-15T12:16:54.843Z",
  "version": "1.0"
}