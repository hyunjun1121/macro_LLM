{
  "id": "reddit_Sheet1_1757928320272_v55q6_1757938302690",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320272_v55q6",
    "description": 8,
    "objective": "Regular",
    "expectedResult": "Save first post",
    "difficulty": "Easy",
    "category": "Click save button on first post and verify it's marked as saved",
    "tags": [
      ".post:first-child .post-action.saved"
    ],
    "notes": "toggleSavePost() saveDataToStorage()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the posts container to appear\n    // Try to locate the first post's save button using multiple strategies\n    // 1. Wait for a post container (assume .post or .post-item or similar)\n    let postSelector = '.post, .post-item, .post-card, [data-testid=\"post-container\"]';\n    let postHandle = null;\n    for (const sel of postSelector.split(',')) {\n      try {\n        postHandle = await page.waitForSelector(sel.trim(), { timeout: 3000 });\n        if (postHandle) break;\n      } catch (e) {}\n    }\n    if (!postHandle) throw new Error('Could not find first post container');\n\n    // Try to find the save button inside the first post\n    // Try common selectors: button[aria-label*=\"Save\"], .save-btn, text=Save\n    let saveBtn = null;\n    const saveSelectors = [\n      'button[aria-label*=\"Save\"]',\n      '.save-btn',\n      'button:has-text(\"Save\")',\n      'text=Save'\n    ];\n    for (const sel of saveSelectors) {\n      try {\n        saveBtn = await postHandle.$(sel);\n        if (saveBtn) break;\n      } catch (e) {}\n    }\n    // If not found, try to find all buttons in the post and pick one with a bookmark icon or \"Save\" text\n    if (!saveBtn) {\n      const buttons = await postHandle.$$('button');\n      for (const btn of buttons) {\n        const btnText = (await btn.innerText()).toLowerCase();\n        if (btnText.includes('save')) {\n          saveBtn = btn;\n          break;\n        }\n        // Check for a bookmark icon\n        const icon = await btn.$('i.fa-bookmark, i.fas.fa-bookmark');\n        if (icon) {\n          saveBtn = btn;\n          break;\n        }\n      }\n    }\n    if (!saveBtn) throw new Error('Could not find Save button in first post');\n\n    // Take screenshot before saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_save.png'));\n\n    // Click the save button\n    await saveBtn.click();\n\n    // Wait for the UI to reflect the saved state\n    // This could be a button text change to \"Saved\", a color change, or an icon change\n    let savedStateDetected = false;\n    let savedBtn = null;\n    // Try to wait for button text to become \"Saved\"\n    try {\n      await page.waitForFunction(\n        el => el && (el.innerText.trim().toLowerCase() === 'saved' || el.innerText.trim().toLowerCase().includes('saved')),\n        saveBtn,\n        { timeout: 3000 }\n      );\n      savedStateDetected = true;\n      savedBtn = saveBtn;\n    } catch (e) {\n      // Try to find a button with \"Saved\" text in the post after clicking\n      const buttons = await postHandle.$$('button');\n      for (const btn of buttons) {\n        const btnText = (await btn.innerText()).toLowerCase();\n        if (btnText.includes('saved')) {\n          savedStateDetected = true;\n          savedBtn = btn;\n          break;\n        }\n      }\n    }\n    // Try to detect a bookmark icon with a filled style (fa-bookmark, fa-solid, etc)\n    if (!savedStateDetected) {\n      const bookmarkIcon = await postHandle.$('i.fa-bookmark, i.fas.fa-bookmark, i.fa-solid.fa-bookmark');\n      if (bookmarkIcon) {\n        // Optionally check for a style change (e.g., color)\n        const color = await bookmarkIcon.evaluate(el => getComputedStyle(el).color);\n        if (color && (color !== 'rgb(128, 128, 128)' && color !== 'gray')) {\n          savedStateDetected = true;\n        }\n      }\n    }\n\n    // Take screenshot after saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_save.png'));\n\n    // Extract relevant data for verification\n    let saveButtonText = '';\n    if (savedBtn) {\n      saveButtonText = await savedBtn.innerText();\n    } else if (saveBtn) {\n      saveButtonText = await saveBtn.innerText();\n    }\n\n    return {\n      success: savedStateDetected,\n      action: \"Clicked save button on first post and verified it's marked as saved\",\n      extractedData: {\n        saveButtonText: saveButtonText.trim(),\n        savedStateDetected\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 22119,
      "timestamp": "2025-09-15T12:11:42.690Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Wait for the main post feed to appear (try to locate by section/heading/text unique to post listing)\n    // Fallback to finding by post title text content, as post titles are present in postsData\n    // Use an XPath selector to locate the first post card by its title text\n    // e.g. \"Just built my first React app! What do you think?\"\n\n    // Wait for first post title to be visible\n    const firstPostTitle = \"Just built my first React app! What do you think?\";\n    const firstPostTitleXPath = `//div[contains(., \"${firstPostTitle}\")]`;\n\n    await page.waitForSelector('text=\"' + firstPostTitle + '\"', { timeout: 5000 });\n\n    // Find the post card containing the first post's title\n    const postHandle = await page.$(`xpath=${firstPostTitleXPath}`);\n\n    if (!postHandle) throw new Error('First post card not found');\n\n    // The Save button is likely inside the post card.\n    // Let's get the parent post card, then look for a button with text \"Save\" inside it.\n\n    // Try to find a button with text 'Save' within the post card\n    // We'll use an XPath relative to the post card node\n\n    const saveButton = await postHandle.$(`xpath=.//button[contains(translate(., 'SAVE', 'save'), 'save')]`);\n\n    if (!saveButton) throw new Error('Save button not found in first post');\n\n    // Take screenshot before clicking Save\n    const beforeSaveShot = path.join(screenshotsDir, 'step_2_before_save.png');\n    await page.screenshot({ path: beforeSaveShot });\n    screenshots.push(beforeSaveShot);\n\n    // Click the Save button\n    await saveButton.click();\n\n    // Wait for the Save button to change state (e.g., text to \"Saved\" or aria-pressed, or a class toggle)\n    // Try to find a button that now contains \"Saved\" (case-insensitive) inside the same post card\n\n    // Wait up to 3 seconds for the button state to change\n    let savedButton;\n    for (let i = 0; i < 6; ++i) {\n      savedButton = await postHandle.$(`xpath=.//button[contains(translate(., 'SAVED', 'saved'), 'saved')]`);\n      if (savedButton) break;\n      await page.waitForTimeout(500);\n    }\n\n    // Take screenshot after clicking Save\n    const afterSaveShot = path.join(screenshotsDir, 'step_3_after_save.png');\n    await page.screenshot({ path: afterSaveShot });\n    screenshots.push(afterSaveShot);\n\n    // Extract the button text/content to verify saved state\n    let savedButtonText = '';\n    if (savedButton) {\n      savedButtonText = (await savedButton.innerText()).trim();\n    }\n\n    // Check if state changed to \"Saved\"\n    const isSaved = savedButtonText && /saved/i.test(savedButtonText);\n\n    return {\n      success: isSaved,\n      action: isSaved\n        ? \"Clicked Save on first post and verified it is marked as saved\"\n        : \"Clicked Save but could not verify saved state\",\n      extractedData: {\n        savedButtonText,\n      },\n      screenshots,\n      error: isSaved ? null : 'Save button did not update to \"Saved\" after clicking'\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 21383,
      "timestamp": "2025-09-15T12:12:04.809Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n\n    // Take initial screenshot\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Wait for post list to appear (use a broad selector to ensure posts loaded)\n    await page.waitForSelector('div.post, article, .post-list', { timeout: 5000 }).catch(() => {});\n\n    // Try to locate the first post using a text and structure-based selector\n    // Since HTML is truncated, we'll use a more universal approach:\n    // Find first post by heading/title text\n    const firstPostTitleSelector = 'main .posts-container .post-title, main .post-list .post-title, .main-container h2, .main-container .post-title, .main-container article h2, .main-container > div:nth-child(2) h2';\n    let firstTitleEl = await page.$(firstPostTitleSelector);\n\n    if (!firstTitleEl) {\n      // Fallback: Find a card or post container and get first h2 inside\n      firstTitleEl = await page.$('.main-container h2');\n    }\n\n    if (!firstTitleEl) {\n      throw new Error('Could not find the first post title element');\n    }\n\n    // Extract title text for verification later\n    const firstPostTitle = await firstTitleEl.evaluate(el => el.innerText.trim());\n\n    // Now, from this title, try to find the nearest \"Save\" button\n    // The Save button is likely a button or span with text \"Save\" near the post actions\n    // We'll use XPath relative to the title\n    const saveButton = await page.evaluateHandle((titleEl) => {\n      // Traverse up to the post container, then look for 'button' or element with \"Save\"\n      let el = titleEl;\n      while (el && !el.classList.contains('post') && !el.classList.contains('post-card') && el !== document.body) {\n        el = el.parentElement;\n      }\n      if (!el) return null;\n      // Try to find a Save button inside this post container\n      const btn = Array.from(el.querySelectorAll('button, span, a')).find(b => \n        b.textContent && b.textContent.trim().toLowerCase() === 'save'\n      );\n      return btn || null;\n    }, firstTitleEl);\n\n    if (!saveButton) {\n      throw new Error('Save button for first post not found');\n    }\n\n    // Scroll to Save button and click it\n    await saveButton.asElement().scrollIntoViewIfNeeded();\n    await saveButton.asElement().click();\n\n    // Wait for a visual confirmation, e.g., button text changes to \"Saved\" or a class changes\n    // We'll check for \"Saved\" text within the same post container\n    let savedConfirmed = false;\n    for (let i = 0; i < 10; i++) {\n      // 10 tries, 200ms apart (2s total)\n      const saved = await page.evaluate((titleText) => {\n        // Find post by title, then look for \"Saved\" button/label in it\n        const posts = Array.from(document.querySelectorAll('.post, .post-card, article, .main-container > div'));\n        for (const post of posts) {\n          const h2 = post.querySelector('h2, .post-title');\n          if (h2 && h2.innerText.trim() === titleText) {\n            // Look for 'Saved'\n            const savedBtn = Array.from(post.querySelectorAll('button, span, a')).find(b => \n              b.textContent && b.textContent.trim().toLowerCase() === 'saved'\n            );\n            return !!savedBtn;\n          }\n        }\n        return false;\n      }, firstPostTitle);\n      if (saved) {\n        savedConfirmed = true;\n        break;\n      }\n      await page.waitForTimeout(200);\n    }\n\n    // Take screenshot after clicking Save\n    const afterSaveShot = path.join(screenshotsDir, 'step_2_after_save.png');\n    await page.screenshot({ path: afterSaveShot });\n    screenshots.push(afterSaveShot);\n\n    // Compose extractedData\n    const extractedData = {\n      firstPostTitle,\n      savedConfirmed\n    };\n\n    return {\n      success: savedConfirmed,\n      action: savedConfirmed\n        ? `Clicked Save on first post ('${firstPostTitle}') and verified it is marked as saved`\n        : \"Clicked Save but could not verify saved status\",\n      extractedData,\n      screenshots,\n      error: savedConfirmed ? null : 'Could not verify saved status after clicking Save'\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 23054,
      "timestamp": "2025-09-15T12:12:26.192Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 66556,
  "timestamp": "2025-09-15T12:11:42.690Z",
  "savedAt": "2025-09-15T12:12:49.246Z",
  "version": "1.0"
}