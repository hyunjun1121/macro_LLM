{
  "id": "reddit_Sheet1_1757928320261_qawpt_1757938610125",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320261_qawpt",
    "description": 12,
    "objective": "Regular",
    "expectedResult": "Test keyboard navigation",
    "difficulty": "Medium",
    "category": "Use Tab key to navigate through interactive elements and verify focus",
    "tags": [
      "focusable elements [tabindex] [role]"
    ],
    "notes": "setupKeyboardNavigation()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Focus should start on the body\n    await page.focus('body');\n\n    // Helper to get the currently focused element's description\n    async function getFocusedElementInfo() {\n      return await page.evaluate(() => {\n        const el = document.activeElement;\n        if (!el) return null;\n        let desc = '';\n        if (el.id) desc += `#${el.id} `;\n        if (el.className) desc += `.${el.className.split(' ').join('.')}`;\n        if (el.tagName) desc = el.tagName.toLowerCase() + ' ' + desc;\n        if (el.getAttribute('aria-label')) desc += ` [aria-label=\"${el.getAttribute('aria-label')}\"]`;\n        if (el.placeholder) desc += ` [placeholder=\"${el.placeholder}\"]`;\n        if (el.innerText && el.innerText.trim().length > 0) desc += ` [text=\"${el.innerText.trim()}\"]`;\n        return desc.trim();\n      });\n    }\n\n    // List of expected tabbable elements in order (as per HTML structure)\n    // We'll check a subset: search input, theme toggle, create post, first community, post title, post community select\n    const tabSteps = [\n      { label: 'Search Reddit input', selector: '#searchInput' },\n      { label: 'Theme toggle button', selector: 'button.theme-toggle-btn' },\n      { label: 'Create post button', selector: 'button.create-post-btn' },\n      { label: 'First community link', selector: '(//button[contains(@class,\"community-link\")])[1]', isXPath: true },\n      { label: 'Post title input', selector: '#postTitle' },\n      { label: 'Post community select', selector: '#postCommunity' }\n    ];\n\n    const focusOrder = [];\n\n    // First Tab: Should focus search input\n    await page.keyboard.press('Tab');\n    await page.waitForSelector('#searchInput', { state: 'focused' });\n    let info = await getFocusedElementInfo();\n    focusOrder.push({ step: 1, label: tabSteps[0].label, info });\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_tab_search.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_tab_search.png'));\n\n    // Second Tab: Theme toggle button\n    await page.keyboard.press('Tab');\n    await page.waitForSelector('button.theme-toggle-btn', { state: 'focused' });\n    info = await getFocusedElementInfo();\n    focusOrder.push({ step: 2, label: tabSteps[1].label, info });\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_tab_theme_toggle.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_tab_theme_toggle.png'));\n\n    // Third Tab: Create post button\n    await page.keyboard.press('Tab');\n    await page.waitForSelector('button.create-post-btn', { state: 'focused' });\n    info = await getFocusedElementInfo();\n    focusOrder.push({ step: 3, label: tabSteps[2].label, info });\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_4_tab_create_post.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_4_tab_create_post.png'));\n\n    // Fourth Tab: First community link (sidebar)\n    await page.keyboard.press('Tab');\n    // Use XPath for first community-link button\n    const [communityBtn] = await page.$x('(//button[contains(@class,\"community-link\")])[1]');\n    if (communityBtn) {\n      await communityBtn.waitForElementState('focused');\n    }\n    info = await getFocusedElementInfo();\n    focusOrder.push({ step: 4, label: tabSteps[3].label, info });\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_5_tab_community.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_5_tab_community.png'));\n\n    // Fifth Tab: Post title input\n    await page.keyboard.press('Tab');\n    await page.waitForSelector('#postTitle', { state: 'focused' });\n    info = await getFocusedElementInfo();\n    focusOrder.push({ step: 5, label: tabSteps[4].label, info });\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_6_tab_post_title.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_6_tab_post_title.png'));\n\n    // Sixth Tab: Post community select\n    await page.keyboard.press('Tab');\n    await page.waitForSelector('#postCommunity', { state: 'focused' });\n    info = await getFocusedElementInfo();\n    focusOrder.push({ step: 6, label: tabSteps[5].label, info });\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_7_tab_post_community.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_7_tab_post_community.png'));\n\n    // Extracted data: the order and info of focused elements\n    return {\n      success: true,\n      action: \"Tested keyboard Tab navigation through main interactive elements and verified focus order and accessibility.\",\n      extractedData: {\n        focusOrder\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 25120,
      "timestamp": "2025-09-15T12:16:50.125Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Screenshots array to collect paths\n    const screenshots = [];\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Focus the body to ensure tab navigation starts from the top\n    await page.focus('body');\n\n    // Store focusable elements' info\n    const focusOrder = [];\n\n    // Helper: Wait for visible text in the search input (as a sanity check)\n    await page.waitForSelector('input[placeholder=\"Search Reddit\"]', { state: 'visible' });\n\n    // Step through several Tab presses, recording the focused element after each\n    // We'll simulate pressing Tab 10 times, which should cover most top elements\n    for (let i = 0; i < 10; i++) {\n      // Press Tab key\n      await page.keyboard.press('Tab');\n      // Give any focus transition a moment\n      await page.waitForTimeout(100);\n\n      // Evaluate: What is currently focused?\n      const focusInfo = await page.evaluate(() => {\n        const el = document.activeElement;\n        if (!el) return null;\n        // Try to extract something meaningful\n        let desc = el.tagName.toLowerCase();\n        if (el.id) desc += `#${el.id}`;\n        if (el.className && typeof el.className === 'string' && el.className.trim()) desc += `.${el.className.trim().split(/\\s+/).join('.')}`;\n        if (el.getAttribute('aria-label')) desc += ` [aria-label=\"${el.getAttribute('aria-label')}\"]`;\n        if (el.placeholder) desc += ` [placeholder=\"${el.placeholder}\"]`;\n        if (el.innerText && el.innerText.trim()) desc += ` [text=\"${el.innerText.trim().slice(0,40)}\"]`;\n        return {\n          tag: el.tagName,\n          id: el.id,\n          className: el.className,\n          ariaLabel: el.getAttribute('aria-label'),\n          placeholder: el.placeholder,\n          text: el.innerText ? el.innerText.trim() : '',\n          desc\n        };\n      });\n      focusOrder.push(focusInfo);\n\n      // Take a screenshot after each Tab to visually verify focus ring\n      const shotPath = path.join(screenshotsDir, `step_${i + 2}_tab_${i + 1}.png`);\n      await page.screenshot({ path: shotPath });\n      screenshots.push(shotPath);\n    }\n\n    // Extract summary: List of focused element descriptions\n    const focusSequence = focusOrder.map(e => e ? e.desc : null);\n\n    return {\n      success: true,\n      action: \"Tested keyboard Tab navigation across interactive elements and recorded focus order with screenshots.\",\n      extractedData: {\n        focusSequence\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 17260,
      "timestamp": "2025-09-15T12:17:15.245Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const step1 = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: step1 });\n    screenshots.push(step1);\n\n    // Prepare to track focus order and focused elements\n    const focusedElements = [];\n\n    // Wait for a clearly focusable element to be ready (search input)\n    await page.waitForSelector('input[placeholder=\"Search Reddit\"]', { state: 'visible', timeout: 5000 });\n\n    // Focus the body to ensure tab sequence starts at the top\n    await page.evaluate(() => document.body.focus());\n\n    // Helper function: get currently focused element's description\n    async function getFocusedElementInfo() {\n      return await page.evaluate(() => {\n        const el = document.activeElement;\n        if (!el) return null;\n        let desc = '';\n        if (el.tagName === 'INPUT') {\n          desc = `INPUT[name=\"${el.name}\"][placeholder=\"${el.placeholder}\"]`;\n        } else if (el.tagName === 'BUTTON') {\n          desc = `BUTTON[class=\"${el.className}\"][text=\"${el.innerText.trim().replace(/\\s+/g, ' ')}\"]`;\n        } else if (el.tagName === 'SELECT') {\n          desc = `SELECT[name=\"${el.name}\"]`;\n        } else {\n          desc = `${el.tagName}[class=\"${el.className}\"]`;\n        }\n        return {\n          tag: el.tagName,\n          class: el.className,\n          id: el.id,\n          name: el.name,\n          placeholder: el.placeholder,\n          text: el.innerText.trim(),\n          ariaLabel: el.getAttribute('aria-label'),\n          description: desc\n        };\n      });\n    }\n\n    // Bring page to known state: click somewhere blank to ensure nothing is focused\n    await page.mouse.click(5, 5);\n\n    // TAB through first 9 interactive elements and record focus order\n    // (search input, theme-toggle-btn, create-post-btn, 'r/programming', 'r/webdev', 'r/javascript', 'r/reactjs', 'View Profile', 'Create Post')\n    for (let i = 0; i < 9; i++) {\n      await page.keyboard.press('Tab');\n      await page.waitForTimeout(200); // Give time for focus to move\n\n      const info = await getFocusedElementInfo();\n      focusedElements.push(info);\n\n      // Take screenshot at the 1st, 3rd, 5th, and 9th tab stops\n      if ([0,2,4,8].includes(i)) {\n        const snapPath = path.join(screenshotsDir, `step_2_tabstop_${i+1}.png`);\n        await page.screenshot({ path: snapPath });\n        screenshots.push(snapPath);\n      }\n    }\n\n    // Extracted data: names of focused elements in tab order\n    const focusTabOrder = focusedElements.map(e => {\n      // Prefer ariaLabel, else description\n      return e.ariaLabel || e.description || `${e.tag}[class=\"${e.class}\"]`;\n    });\n\n    // Confirm that at least the following elements are reached in order:\n    // 1. Search input\n    // 2. Theme toggle button\n    // 3. Create post button\n    // 4-7. Community links (by their aria-label)\n    // 8-9. Quick action buttons (by their aria-label or text)\n    // We'll extract up to 9 tab stops.\n\n    return {\n      success: true,\n      action: \"Tested keyboard Tab navigation order and verified focus transitions through interactive elements (inputs, buttons). Screenshots captured at key tab stops.\",\n      extractedData: {\n        focusTabOrder\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 20082,
      "timestamp": "2025-09-15T12:17:32.505Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 62462,
  "timestamp": "2025-09-15T12:16:50.125Z",
  "savedAt": "2025-09-15T12:17:52.587Z",
  "version": "1.0"
}