{
  "id": "reddit_Sheet1_1757928320240_m2vqt_1757938292530",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320240_m2vqt",
    "description": 8,
    "objective": "Regular",
    "expectedResult": "Save first post",
    "difficulty": "Easy",
    "category": "Click save button on first post and verify it's marked as saved",
    "tags": [
      ".post:first-child .post-action.saved"
    ],
    "notes": "toggleSavePost() saveDataToStorage()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the posts list to be rendered\n    // Try to find a post container (assuming posts are rendered in a main content area)\n    // We'll look for a post by its title text or a common post class\n    // Try several strategies\n\n    // Wait for the first post title to appear (from sample data: \"Just built my first React app! What do you think?\")\n    const firstPostTitle = \"Just built my first React app! What do you think?\";\n    await page.waitForSelector(`text=\"${firstPostTitle}\"`, { timeout: 5000 });\n\n    // Find the post container for the first post\n    // Try to get the parent of the title node, then search for a save button inside\n    const postTitleElement = await page.$(`text=\"${firstPostTitle}\"`);\n    if (!postTitleElement) throw new Error('First post title not found');\n\n    // Get the post container (assume it's the closest article or div with a class)\n    const postContainer = await postTitleElement.evaluateHandle((node) => {\n      let el = node;\n      while (el && el.parentElement) {\n        el = el.parentElement;\n        if (\n          el.classList &&\n          (el.classList.contains('post') ||\n            el.classList.contains('post-container') ||\n            el.getAttribute('data-post-id'))\n        ) {\n          return el;\n        }\n      }\n      // fallback: return the grandparent\n      return node.parentElement?.parentElement || node.parentElement;\n    });\n\n    // Now, within this post container, look for a save button\n    // Try to find a button with text \"Save\" or a save icon (fa-bookmark)\n    let saveButton = null;\n\n    // Try by text\n    saveButton = await postContainer.$('button:has-text(\"Save\")');\n    if (!saveButton) {\n      // Try to find by icon (FontAwesome 'fa-bookmark')\n      saveButton = await postContainer.$('button >> i.fa-bookmark');\n    }\n    if (!saveButton) {\n      // Try to find any button with aria-label containing 'save'\n      saveButton = await postContainer.$('button[aria-label*=\"save\" i]');\n    }\n    if (!saveButton) {\n      // Try to find any button with title containing 'save'\n      saveButton = await postContainer.$('button[title*=\"save\" i]');\n    }\n    if (!saveButton) {\n      // Fallback: try to find any button in the post container\n      const allButtons = await postContainer.$$('button');\n      for (const btn of allButtons) {\n        const text = (await btn.textContent())?.toLowerCase();\n        if (text && text.includes('save')) {\n          saveButton = btn;\n          break;\n        }\n      }\n    }\n\n    if (!saveButton) throw new Error('Save button not found in first post');\n\n    // Take screenshot before saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_save.png'));\n\n    // Click the save button\n    await saveButton.click();\n\n    // Wait for the post to be marked as saved\n    // This could be a button text change to \"Saved\", a color change, or an icon change\n    // Wait for button text to become \"Saved\" or aria-pressed to be true\n    let saved = false;\n    for (let i = 0; i < 10; i++) {\n      // Try to find the button again (it may have re-rendered)\n      let savedBtn = await postContainer.$('button:has-text(\"Saved\")');\n      if (!savedBtn) {\n        // Try aria-pressed\n        const btns = await postContainer.$$('button');\n        for (const btn of btns) {\n          const text = (await btn.textContent())?.trim().toLowerCase();\n          const ariaPressed = await btn.getAttribute('aria-pressed');\n          if (text === 'saved' || ariaPressed === 'true') {\n            savedBtn = btn;\n            break;\n          }\n        }\n      }\n      if (savedBtn) {\n        saved = true;\n        break;\n      }\n      // Wait a bit and retry\n      await page.waitForTimeout(300);\n    }\n\n    // Take screenshot after saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_save.png'));\n\n    // Extract verification data: check if the save button now says \"Saved\"\n    let saveButtonText = null;\n    let isSaved = false;\n    // Re-query the save button in the post container\n    const allPostButtons = await postContainer.$$('button');\n    for (const btn of allPostButtons) {\n      const text = (await btn.textContent())?.trim();\n      if (text && text.toLowerCase().includes('saved')) {\n        saveButtonText = text;\n        isSaved = true;\n        break;\n      }\n      // Check aria-pressed\n      const ariaPressed = await btn.getAttribute('aria-pressed');\n      if (ariaPressed === 'true') {\n        saveButtonText = text;\n        isSaved = true;\n        break;\n      }\n    }\n\n    return {\n      success: isSaved,\n      action: \"Clicked save button on first post and verified it is marked as saved\",\n      extractedData: {\n        firstPostTitle,\n        saveButtonText,\n        isSaved\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 25880,
      "timestamp": "2025-09-15T12:11:32.530Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the main post feed to appear (by main content region)\n    await page.waitForSelector('main', { timeout: 7000 });\n\n    // Find the first post using an alternative selector: locate an article with a post title\n    // Try to get the first post title element (using text and role, fallback to h2)\n    let firstPost;\n    try {\n      firstPost = await page.waitForSelector('article >> h2', { timeout: 5000 });\n    } catch {\n      // Fallback: any h2 in main\n      firstPost = await page.waitForSelector('main h2', { timeout: 3000 });\n    }\n\n    // Scroll to the first post (ensure it's in viewport)\n    await firstPost.scrollIntoViewIfNeeded();\n\n    // Get the article (post container) of the first post (go up DOM tree)\n    const firstPostArticle = await firstPost.evaluateHandle(node => {\n      let el = node;\n      while (el && el.tagName !== 'ARTICLE') el = el.parentElement;\n      return el;\n    });\n\n    // Take screenshot before saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_save.png'));\n\n    // Find the save button inside the first post\n    // Try by button text \"Save\" or aria-label \"Save post\"\n    let saveButton = null;\n    try {\n      // Try text selector\n      saveButton = await firstPostArticle.$('button:has-text(\"Save\")');\n    } catch {}\n    if (!saveButton) {\n      // Try aria-label\n      saveButton = await firstPostArticle.$('button[aria-label*=\"Save\"]');\n    }\n    if (!saveButton) {\n      // Try icon + tooltip fallback\n      const allButtons = await firstPostArticle.$$('button');\n      for (const btn of allButtons) {\n        const btnText = await btn.textContent();\n        if (btnText && btnText.trim().toLowerCase().includes('save')) {\n          saveButton = btn;\n          break;\n        }\n      }\n    }\n    if (!saveButton) {\n      throw new Error(\"Could not find the Save button on the first post\");\n    }\n\n    // Click the save button\n    await saveButton.click();\n    // Wait briefly for UI update\n    await page.waitForTimeout(800);\n\n    // Take screenshot after saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_save.png'));\n\n    // Verify that the post is marked as saved\n    // Try to see if button text changed to \"Saved\" or aria-pressed/aria-checked is set\n    let saved = false;\n    let saveBtnText = await saveButton.textContent();\n    if (saveBtnText && saveBtnText.trim().toLowerCase().includes('saved')) {\n      saved = true;\n    } else {\n      // Try to get attribute\n      const ariaPressed = await saveButton.getAttribute('aria-pressed');\n      if (ariaPressed === 'true' || ariaPressed === 'checked') saved = true;\n      // Try class change\n      const btnClass = await saveButton.getAttribute('class');\n      if (btnClass && btnClass.toLowerCase().includes('saved')) saved = true;\n    }\n\n    // Extract the title of first post for reporting\n    const postTitle = await firstPost.textContent();\n\n    return {\n      success: saved,\n      action: saved\n        ? `Clicked save on the first post and verified it is marked as saved`\n        : `Clicked save on the first post, but could not verify saved state`,\n      extractedData: {\n        firstPostTitle: postTitle ? postTitle.trim() : null,\n        saved,\n      },\n      screenshots,\n      error: saved ? null : \"Could not verify saved state for the post\"\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 19293,
      "timestamp": "2025-09-15T12:11:58.410Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Step 1: Initial screenshot of the homepage\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Step 2: Wait for posts to be loaded on the page (look for a post title)\n    // Use XPath to select the first post's card by looking for the post container\n    // Use text and role-based selectors for robustness\n    // Assume posts are in a main content area with post titles as <h2>\n    await page.waitForSelector('main h2');\n    const firstPostTitleLocator = await page.locator('main h2').first();\n    const firstPostTitle = await firstPostTitleLocator.innerText();\n\n    // Step 3: Find the \"Save\" button for the first post\n    // Try to find the \"Save\" button within the first post container\n    // The button may be labeled \"Save\" or have an icon (use text selector and fallback to aria-label)\n    // Let's use XPath to get the first post card and then query for its Save button\n    const firstPostCard = (await page.$$('//main//article | //main//div[contains(@class,\"post\")] | //main//div[.//h2]'))[0];\n    let saveButton;\n    if (firstPostCard) {\n      // Try text selector within the post card\n      saveButton = await firstPostCard.$('button:has-text(\"Save\")');\n      if (!saveButton) {\n        // Try aria-label\n        saveButton = await firstPostCard.$('button[aria-label*=\"Save\"]');\n      }\n      if (!saveButton) {\n        // Try icon with title or svg\n        saveButton = await firstPostCard.$('button:has(svg[title*=\"Save\"]), button:has(i.fa-bookmark)');\n      }\n    } else {\n      // Fallback: select first visible Save button on page\n      saveButton = await page.$('button:has-text(\"Save\")');\n      if (!saveButton) {\n        saveButton = await page.$('button[aria-label*=\"Save\"]');\n      }\n    }\n\n    if (!saveButton) {\n      throw new Error('Could not locate Save button for the first post.');\n    }\n\n    // Step 4: Click the Save button\n    await saveButton.click();\n\n    // Step 5: Wait for visual feedback (button text changes to \"Saved\" or gets an active style)\n    // We'll wait for either a button text change or a class toggle\n    let savedButton;\n    // Try to wait for the button text to change to \"Saved\"\n    await page.waitForTimeout(600); // slight delay for UI update\n    if (firstPostCard) {\n      savedButton = await firstPostCard.$('button:has-text(\"Saved\")');\n      if (!savedButton) {\n        // Try aria-pressed or class toggle\n        savedButton = await firstPostCard.$('button[aria-pressed=\"true\"], button.active, button.saved');\n      }\n    } else {\n      savedButton = await page.$('button:has-text(\"Saved\")');\n    }\n\n    // Take screenshot after saving\n    const afterSaveShot = path.join(screenshotsDir, 'step_2_after_save.png');\n    await page.screenshot({ path: afterSaveShot });\n    screenshots.push(afterSaveShot);\n\n    // Step 6: Extract verification info\n    let isSaved = false;\n    if (savedButton) {\n      isSaved = true;\n    } else {\n      // Additionally, check if the Save button text changed\n      const saveButtonText = await saveButton.innerText();\n      if (saveButtonText.trim().toLowerCase() === 'saved') {\n        isSaved = true;\n      }\n    }\n\n    return {\n      success: isSaved,\n      action: isSaved\n        ? `Clicked Save on the first post titled \"${firstPostTitle}\" and verified it is marked as saved`\n        : \"Clicked Save on the first post, but could not verify it was marked as saved\",\n      extractedData: {\n        firstPostTitle,\n        savedStatus: isSaved\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 21033,
      "timestamp": "2025-09-15T12:12:17.703Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 66206,
  "timestamp": "2025-09-15T12:11:32.530Z",
  "savedAt": "2025-09-15T12:12:38.736Z",
  "version": "1.0"
}