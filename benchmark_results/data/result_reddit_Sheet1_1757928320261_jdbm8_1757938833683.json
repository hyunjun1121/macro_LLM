{
  "id": "reddit_Sheet1_1757928320261_jdbm8_1757938833683",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320261_jdbm8",
    "description": 15,
    "objective": "Regular",
    "expectedResult": "Switch to New tab and verify sorting",
    "difficulty": "Medium",
    "category": "Click New tab button and verify posts are sorted by newest first",
    "tags": [
      "#new-tab .tab-btn[data-tab='new']"
    ],
    "notes": "switchTab('new') renderPosts()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the sorting tabs/buttons to be visible\n    // Try to locate the \"New\" tab by text (case-insensitive)\n    const newTabSelector = `//button[contains(translate(., 'NEW', 'new'), 'new')] | //a[contains(translate(., 'NEW', 'new'), 'new')]`;\n    await page.waitForSelector(newTabSelector, { timeout: 5000 });\n\n    // Take screenshot before clicking \"New\"\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_new_tab.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_new_tab.png'));\n\n    // Click the \"New\" tab\n    const [newTabButton] = await page.$x(newTabSelector);\n    if (!newTabButton) throw new Error('Could not find \"New\" tab button');\n    await newTabButton.click();\n\n    // Wait for posts to update/sort (simulate dynamic content)\n    // Wait for a short while to allow sorting to take effect\n    await page.waitForTimeout(1000);\n\n    // Take screenshot after clicking \"New\"\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_new_tab.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_new_tab.png'));\n\n    // Extract post titles and their time labels\n    // Assume posts are in a list with a recognizable class or role\n    // Try several selectors for robustness\n    let postSelector = '.post, .post-item, [role=\"article\"], .post-list-item';\n    let postElements = await page.$$(postSelector);\n    if (postElements.length === 0) {\n      // Try a more generic approach: find all articles\n      postSelector = 'article';\n      postElements = await page.$$(postSelector);\n    }\n    if (postElements.length === 0) {\n      // Try a fallback: find all divs with time labels\n      postSelector = 'div';\n      postElements = await page.$$(postSelector);\n    }\n\n    // Extract up to 5 post titles and their time labels\n    const posts = [];\n    for (let i = 0; i < Math.min(5, postElements.length); i++) {\n      const el = postElements[i];\n      // Try to get the title: look for h2, h3, or strong inside the post\n      let title = await el.$eval('h2', n => n.textContent).catch(() => null);\n      if (!title) title = await el.$eval('h3', n => n.textContent).catch(() => null);\n      if (!title) title = await el.$eval('strong', n => n.textContent).catch(() => null);\n      if (!title) title = await el.textContent();\n      // Try to get the time label: look for elements containing \"ago\" or time\n      let timeLabel = await el.$eval('*', n => n.textContent.match(/(\\d+\\s*(minute|hour|day|second)s?\\s*ago)/i)?.[0]).catch(() => null);\n      if (!timeLabel) {\n        // Try to find any span or div with \"ago\"\n        const timeEl = await el.$(':text(\"ago\")');\n        if (timeEl) timeLabel = await timeEl.textContent();\n      }\n      posts.push({\n        title: title ? title.trim() : '',\n        time: timeLabel ? timeLabel.trim() : ''\n      });\n    }\n\n    // Check if posts are sorted by newest first (e.g., first post has smallest time)\n    // We'll parse the time strings to estimate recency\n    function parseTime(t) {\n      if (!t) return Number.MAX_SAFE_INTEGER;\n      const m = t.match(/(\\d+)\\s*(second|minute|hour|day)s?\\s*ago/i);\n      if (!m) return Number.MAX_SAFE_INTEGER;\n      const num = parseInt(m[1], 10);\n      const unit = m[2].toLowerCase();\n      if (unit.startsWith('second')) return num;\n      if (unit.startsWith('minute')) return num * 60;\n      if (unit.startsWith('hour')) return num * 3600;\n      if (unit.startsWith('day')) return num * 86400;\n      return Number.MAX_SAFE_INTEGER;\n    }\n    let sorted = true;\n    for (let i = 1; i < posts.length; i++) {\n      if (parseTime(posts[i].time) < parseTime(posts[i - 1].time)) {\n        sorted = false;\n        break;\n      }\n    }\n\n    // Take screenshot of the extracted posts (optional)\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_4_extracted_posts.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_4_extracted_posts.png'));\n\n    return {\n      success: sorted,\n      action: sorted\n        ? 'Switched to \"New\" tab and verified posts are sorted by newest first'\n        : 'Switched to \"New\" tab but posts are NOT sorted by newest first',\n      extractedData: {\n        posts\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 27615,
      "timestamp": "2025-09-15T12:20:33.683Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // --- Wait for the sorting tabs/buttons to be visible ---\n    // Try to use a different selector strategy: locate by text content \"New\" as a tab or button\n    // Use xpath to find the \"New\" tab/button, which should sort by newest first\n    const [newTab] = await page.$x(\n      \"//button[contains(., 'New') or contains(., 'new') or contains(., 'Newest')]\"\n    );\n    if (!newTab) {\n      // Try with alternative: maybe it's a link or span\n      const [newTabAlt] = await page.$x(\n        \"//*[self::a or self::span][contains(., 'New') or contains(., 'new') or contains(., 'Newest')]\"\n      );\n      if (!newTabAlt) {\n        throw new Error('Could not find the \"New\" sorting tab/button');\n      }\n      await newTabAlt.click();\n    } else {\n      await newTab.click();\n    }\n\n    // Wait for posts to re-render. We'll wait for a small delay and for at least one post to be visible.\n    await page.waitForTimeout(600); // Give time for sorting animation if any\n\n    // Find posts container: try to use role or class strategy\n    // Try to locate a post card by heading or unique structure\n    // For this demo, let's assume post titles are <h3> elements inside a post list\n    await page.waitForSelector('h3', { timeout: 3000 });\n\n    // Screenshot after sorting\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_sort_new.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_sort_new.png'));\n\n    // Extract post titles and time labels to verify sorting\n    const posts = await page.$$eval('div', divs => {\n      // Find divs that look like post containers by searching for h3 and a time string\n      return divs\n        .map(div => {\n          const titleEl = div.querySelector('h3');\n          const timeEl = Array.from(div.querySelectorAll('span, time'))\n            .find(n => /ago$|minute|hour|day|week/.test(n.textContent || ''));\n          return titleEl && timeEl\n            ? {\n                title: titleEl.textContent.trim(),\n                time: timeEl.textContent.trim()\n              }\n            : null;\n        })\n        .filter(Boolean);\n    });\n\n    // Check if posts are sorted by \"new\" (i.e., most recent post on top)\n    // We'll consider \"X hours/minutes ago\" as the \"newest\" if it's less than the next post\n    function parseTimeToMinutes(str) {\n      // E.g., \"2 hours ago\", \"5 minutes ago\", \"1 day ago\"\n      const m = /(\\d+)\\s*(minute|hour|day|week)/i.exec(str);\n      if (!m) return Number.MAX_SAFE_INTEGER;\n      const num = parseInt(m[1]);\n      if (/minute/.test(m[2])) return num;\n      if (/hour/.test(m[2])) return num * 60;\n      if (/day/.test(m[2])) return num * 24 * 60;\n      if (/week/.test(m[2])) return num * 7 * 24 * 60;\n      return Number.MAX_SAFE_INTEGER;\n    }\n\n    let sorted = true;\n    for (let i = 0; i < posts.length - 1; ++i) {\n      const t1 = parseTimeToMinutes(posts[i].time);\n      const t2 = parseTimeToMinutes(posts[i + 1].time);\n      if (t1 > t2) {\n        sorted = false;\n        break;\n      }\n    }\n\n    return {\n      success: sorted,\n      action: 'Clicked the \"New\" tab and verified posts are sorted by newest first',\n      extractedData: {\n        sortedByNew: sorted,\n        posts: posts.slice(0, 5) // show top 5 posts with their time\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 23906,
      "timestamp": "2025-09-15T12:21:01.298Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for main sorting tab area to be visible (using ARIA label as alternate strategy)\n    await page.waitForSelector('[role=\"tablist\"]', { timeout: 4000 });\n\n    // Find the \"New\" tab button\n    // Try text content and then fallback for robustness\n    let newTabBtn = await page.$('//button[contains(., \"New\")]');\n    if (!newTabBtn) {\n      newTabBtn = await page.$('button[aria-label*=\"New\"]');\n    }\n    if (!newTabBtn) {\n      // Try tablist children buttons: pick the one with \"New\"\n      const tabButtons = await page.$$('[role=\"tablist\"] button');\n      for (const btn of tabButtons) {\n        const txt = await btn.textContent();\n        if (txt && txt.trim().toLowerCase() === 'new') {\n          newTabBtn = btn;\n          break;\n        }\n      }\n    }\n\n    if (!newTabBtn) {\n      throw new Error('Could not find the New tab button');\n    }\n\n    // Click the \"New\" tab\n    await newTabBtn.click();\n\n    // Wait for posts to update (assume posts container has role=\"list\" or class)\n    // We'll wait for the first post's title to appear and change\n    await page.waitForTimeout(800); // brief wait for UI update\n\n    // Screenshot after clicking New tab\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_new_tab.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_new_tab.png'));\n\n    // Extract post titles and times for verification\n    // Try to find post items by role=\"listitem\" under role=\"list\"\n    let postListSelector = '[role=\"list\"]';\n    await page.waitForSelector(postListSelector, { timeout: 4000 });\n\n    const posts = await page.$$(`${postListSelector} [role=\"listitem\"]`);\n    if (!posts || posts.length < 2) {\n      throw new Error('Not enough posts found for sorting verification');\n    }\n\n    // Extract title and time for the first few posts\n    const extractedPosts = [];\n    for (let i = 0; i < Math.min(3, posts.length); i++) {\n      const post = posts[i];\n      // Try to find h3 (title) and time element or similar\n      const titleEl = await post.$('h3') || await post.$('h2');\n      const timeEl = await post.$('time') || await post.$('span[class*=\"time\"]') || await post.$('span:has-text(\"ago\")');\n      const title = titleEl ? (await titleEl.textContent()).trim() : null;\n      let timeText = null;\n      if (timeEl) {\n        timeText = (await timeEl.textContent()).trim();\n      } else {\n        // Fallback: try to find any span that looks like a time\n        const spans = await post.$$('span');\n        for (const s of spans) {\n          const t = await s.textContent();\n          if (t && t.match(/(minute|hour|day|ago)/i)) {\n            timeText = t.trim();\n            break;\n          }\n        }\n      }\n      extractedPosts.push({ title, time: timeText });\n    }\n\n    // Simple verification: the first post's time should be \"minutes ago\" or \"hours ago\"\n    const sortedByNewest =\n      extractedPosts.length > 1 &&\n      extractedPosts[0].time &&\n      extractedPosts[0].time.match(/(minute|hour|just now)/i);\n\n    return {\n      success: sortedByNewest,\n      action: 'Switched to New tab and verified posts are sorted by newest first',\n      extractedData: {\n        postsPreview: extractedPosts,\n        sortedByNewest\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 21245,
      "timestamp": "2025-09-15T12:21:25.204Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 72766,
  "timestamp": "2025-09-15T12:20:33.683Z",
  "savedAt": "2025-09-15T12:21:46.449Z",
  "version": "1.0"
}