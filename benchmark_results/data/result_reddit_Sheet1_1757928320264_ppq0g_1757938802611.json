{
  "id": "reddit_Sheet1_1757928320264_ppq0g_1757938802611",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320264_ppq0g",
    "description": 15,
    "objective": "Regular",
    "expectedResult": "Switch to New tab and verify sorting",
    "difficulty": "Medium",
    "category": "Click New tab button and verify posts are sorted by newest first",
    "tags": [
      "#new-tab .tab-btn[data-tab='new']"
    ],
    "notes": "switchTab('new') renderPosts()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the sorting tabs/buttons to appear\n    // Try to find a tab/button with text \"New\" or similar\n    // Try several selector strategies\n    let newTabSelector = null;\n    // Try by text first\n    const newTabByText = await page.$(`text=/^New$/i`);\n    if (newTabByText) {\n      newTabSelector = `text=/^New$/i`;\n    } else {\n      // Try by role and name\n      const newTabByRole = await page.$(`role=button[name=\"New\"]`);\n      if (newTabByRole) {\n        newTabSelector = `role=button[name=\"New\"]`;\n      } else {\n        // Try by class or other means (commonly .tab or .sort)\n        const possibleTabs = await page.$$('button, a');\n        for (const el of possibleTabs) {\n          const text = (await el.innerText()).trim().toLowerCase();\n          if (text === 'new' || text.includes('newest')) {\n            newTabSelector = el;\n            break;\n          }\n        }\n      }\n    }\n\n    // If we found a selector, click it; else, throw error\n    if (typeof newTabSelector === 'string') {\n      await page.waitForSelector(newTabSelector, { timeout: 3000 });\n      await page.click(newTabSelector);\n    } else if (newTabSelector) {\n      // It's an element handle\n      await newTabSelector.click();\n    } else {\n      throw new Error('Could not find the \"New\" tab/button for sorting.');\n    }\n\n    // Wait for posts to reload/sort (simulate network delay)\n    await page.waitForTimeout(1000);\n\n    // Take screenshot after switching to \"New\" tab\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_new_tab.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_new_tab.png'));\n\n    // Extract the post titles and their time labels (to verify sorting)\n    // Try to find post containers\n    let postSelector = '.post, .post-card, .post-item, article, .post-container';\n    let postElements = await page.$$(postSelector);\n    if (postElements.length === 0) {\n      // Try a more generic selector\n      postElements = await page.$$('div');\n    }\n\n    // For each post, try to extract title and time\n    const posts = [];\n    for (const post of postElements) {\n      // Try to find a title\n      let title = '';\n      let time = '';\n      try {\n        // Try heading tags first\n        const titleHandle = await post.$('h2, h3, .post-title, .title');\n        if (titleHandle) {\n          title = (await titleHandle.innerText()).trim();\n        } else {\n          // Try direct text\n          title = (await post.innerText()).split('\\n')[0].trim();\n        }\n        // Try to find time label\n        const timeHandle = await post.$('.time, time, .post-time');\n        if (timeHandle) {\n          time = (await timeHandle.innerText()).trim();\n        } else {\n          // Try to find a string like \"hour\" or \"minute\" or \"day\"\n          const allText = (await post.innerText());\n          const timeMatch = allText.match(/(\\d+\\s+(minute|hour|day)s?\\s+ago)/i);\n          if (timeMatch) {\n            time = timeMatch[1];\n          }\n        }\n      } catch (e) {}\n      if (title && time) {\n        posts.push({ title, time });\n      }\n      if (posts.length >= 5) break; // Only need top 5 for verification\n    }\n\n    // Verify sorting: check if times are in order from newest to oldest\n    // We'll assign a rough numeric value to each time for comparison\n    function timeToMinutes(timeStr) {\n      if (!timeStr) return 99999;\n      const m = timeStr.match(/(\\d+)\\s*(minute|hour|day)/i);\n      if (!m) return 99999;\n      const num = parseInt(m[1]);\n      if (m[2].startsWith('minute')) return num;\n      if (m[2].startsWith('hour')) return num * 60;\n      if (m[2].startsWith('day')) return num * 1440;\n      return 99999;\n    }\n    let sorted = true;\n    for (let i = 1; i < posts.length; ++i) {\n      if (timeToMinutes(posts[i].time) < timeToMinutes(posts[i - 1].time)) {\n        sorted = false;\n        break;\n      }\n    }\n\n    return {\n      success: sorted,\n      action: 'Switched to \"New\" tab and verified posts are sorted by newest first',\n      extractedData: {\n        posts: posts,\n        sortedNewestFirst: sorted\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 24252,
      "timestamp": "2025-09-15T12:20:02.611Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the sorting tabs to appear (try to use a text selector for 'New', fallback to aria-label or nth-child)\n    // We will use an XPath selector for robustness and to avoid previous selector issues.\n    // Try to find a tab or button whose text is 'New'\n    const newTabXPath = \"//button[normalize-space()='New' or .//*[normalize-space(text())='New']]\";\n    await page.waitForSelector(newTabXPath, { timeout: 5000 });\n\n    // Take a screenshot before clicking New tab\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_tabs_visible.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_tabs_visible.png'));\n\n    // Click on the 'New' tab\n    const [newTabBtn] = await page.$x(newTabXPath);\n    if (!newTabBtn) {\n      throw new Error(\"Could not find 'New' tab button via XPath\");\n    }\n    await newTabBtn.click();\n\n    // Wait for posts to re-render after clicking 'New'\n    // Wait for a short delay to let sorting apply (simulate network, JS sorting, etc)\n    await page.waitForTimeout(1200);\n\n    // Take a screenshot after clicking New tab\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_new_tab_clicked.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_new_tab_clicked.png'));\n\n    // Extract the visible post titles in their order\n    // Try to extract post elements by their container class, fallback to heading tags in post list\n    // We'll use a flexible selector: all h3 nodes inside a post list/container\n    const postTitleHandles = await page.$$('main h3, .post-list h3, .posts-container h3');\n    if (!postTitleHandles || postTitleHandles.length === 0) {\n      throw new Error('Could not find any post titles after sorting by New');\n    }\n\n    // Get titles as array\n    const postTitles = [];\n    for (const handle of postTitleHandles) {\n      const title = await handle.evaluate(node => node.innerText.trim());\n      if (title) postTitles.push(title);\n    }\n\n    // Additionally, try to extract post timestamp or age if available (e.g. \"2 hours ago\")\n    // We'll look for all elements within the first 3 posts which contain \"ago\" or \"day\"\n    // Use XPath to find time labels in posts\n    const timeLabels = [];\n    for (let i = 1; i <= 3; i++) {\n      const postTimeXPath = `(//main//article | //main//div[contains(@class, 'post')])[${i}]//*[contains(text(),'ago') or contains(text(),'day')]`;\n      const [timeElem] = await page.$x(postTimeXPath);\n      if (timeElem) {\n        const timeText = await timeElem.evaluate(node => node.innerText.trim());\n        timeLabels.push(timeText);\n      }\n    }\n\n    // Prepare extractedData for verification\n    const extractedData = {\n      postTitles,\n      top3PostTimes: timeLabels\n    };\n\n    // Determine if posts are sorted by newest (e.g. \"2 hours ago\" before \"5 hours ago\", then \"1 day ago\", etc)\n    // We'll check that the first post is the most recent (e.g. \"hours ago\" or \"minutes ago\"), not \"days ago\"\n    let sortingIsLikelyCorrect = false;\n    if (timeLabels.length >= 2) {\n      // Convert time expressions to an approximate number of minutes for comparison\n      function toMinutes(label) {\n        if (!label) return 99999;\n        const m = label.match(/(\\d+)\\s*(minute|hour|day)/);\n        if (!m) return 99999;\n        const val = parseInt(m[1]);\n        if (m[2].startsWith('minute')) return val;\n        if (m[2].startsWith('hour')) return val * 60;\n        if (m[2].startsWith('day')) return val * 24 * 60;\n        return 99999;\n      }\n      const mins = timeLabels.map(toMinutes);\n      sortingIsLikelyCorrect = mins[0] <= mins[1] && (mins.length < 3 || mins[1] <= mins[2]);\n    }\n\n    // Take a final screenshot with posts sorted by New\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_4_sorted_newest.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_4_sorted_newest.png'));\n\n    return {\n      success: sortingIsLikelyCorrect,\n      action: \"Clicked the 'New' tab and verified posts appear sorted by newest first\",\n      extractedData,\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 26749,
      "timestamp": "2025-09-15T12:20:26.863Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const step1 = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: step1 });\n    screenshots.push(step1);\n\n    // Wait for the sorting tabs to be visible\n    // Use role and text selectors to be different from previous attempts\n    // Try to find the \"New\" tab - assume it's a button or tab with \"New\" text\n    const newTabSelector = 'button:has-text(\"New\"), [role=\"tab\"]:has-text(\"New\"), text=\"New\"';\n    await page.waitForSelector(newTabSelector, { timeout: 5000 });\n\n    // Take screenshot before clicking \"New\" tab\n    const step2 = path.join(screenshotsDir, 'step_2_before_click_new_tab.png');\n    await page.screenshot({ path: step2 });\n    screenshots.push(step2);\n\n    // Click the \"New\" tab using the first match from the selector list\n    const newTabElement = await page.$('button:has-text(\"New\")') ||\n                          await page.$('[role=\"tab\"]:has-text(\"New\")') ||\n                          await page.$('text=\"New\"');\n    if (!newTabElement) {\n      throw new Error('Could not find the \"New\" tab on the page.');\n    }\n    await newTabElement.click();\n\n    // Wait for posts to update (simulate dynamic loading)\n    // Wait for a brief moment or for posts list to update\n    await page.waitForTimeout(1200);\n\n    // Take screenshot after clicking \"New\" tab\n    const step3 = path.join(screenshotsDir, 'step_3_after_click_new_tab.png');\n    await page.screenshot({ path: step3 });\n    screenshots.push(step3);\n\n    // Extract the post times from the first 3 posts\n    // Try to use the visible time element, using xpath and role strategies\n    // Try to find elements that might have time info, e.g. //article//span[contains(text(),'ago')]\n    const postTimeXpaths = [\n      \"//article//span[contains(text(),'ago')]\",\n      \"//div[contains(@class,'post') or contains(@class,'Post') or contains(@class,'card')]//span[contains(text(),'ago')]\",\n      \"//span[contains(text(),'ago')]\"\n    ];\n    let postTimes = [];\n    for (const xpath of postTimeXpaths) {\n      const timeElements = await page.$$(xpath);\n      if (timeElements.length >= 3) {\n        for (let i = 0; i < 3; i++) {\n          const txt = await timeElements[i].innerText();\n          postTimes.push(txt.trim());\n        }\n        break;\n      }\n    }\n    if (postTimes.length < 3) {\n      // fallback: select all visible spans with 'ago' text\n      const allTimeEls = await page.$$('span');\n      for (const el of allTimeEls) {\n        const txt = await el.innerText();\n        if (txt && txt.toLowerCase().includes('ago')) {\n          postTimes.push(txt.trim());\n        }\n        if (postTimes.length >= 3) break;\n      }\n    }\n\n    // Extract post titles as well for clarity\n    // Try to get the first 3 post titles using xpath, class, or role strategies\n    let postTitles = [];\n    // Try several selector strategies\n    const titleXpaths = [\n      \"//article//h3\",\n      \"//div[contains(@class,'post') or contains(@class,'Post') or contains(@class,'card')]//h3\",\n      \"//h3\"\n    ];\n    for (const xpath of titleXpaths) {\n      const titleElements = await page.$$(xpath);\n      if (titleElements.length >= 3) {\n        for (let i = 0; i < 3; i++) {\n          const txt = await titleElements[i].innerText();\n          postTitles.push(txt.trim());\n        }\n        break;\n      }\n    }\n    if (postTitles.length < 3) {\n      // fallback: select all h3s\n      const allH3s = await page.$$('h3');\n      for (const el of allH3s) {\n        const txt = await el.innerText();\n        if (txt && txt.length > 0) {\n          postTitles.push(txt.trim());\n        }\n        if (postTitles.length >= 3) break;\n      }\n    }\n\n    // Compose extractedData\n    const extractedData = {\n      postTimes: postTimes.slice(0, 3),\n      postTitles: postTitles.slice(0, 3)\n    };\n\n    // Heuristic: Verify if posts are sorted by newest first (e.g., \"1 hour ago\", \"2 hours ago\", \"5 hours ago\", ...)\n    // We'll check if the first time is \"newer\" than the second, etc.\n    function parseAgo(str) {\n      // Returns {n, unit} or null\n      const m = str.match(/(\\d+)\\s*(minute|hour|day|second|week)/i);\n      if (!m) return null;\n      let n = parseInt(m[1], 10);\n      let unit = m[2].toLowerCase();\n      return { n, unit };\n    }\n    let sorted = true;\n    for (let i = 0; i < postTimes.length - 1; i++) {\n      const a = parseAgo(postTimes[i]);\n      const b = parseAgo(postTimes[i + 1]);\n      if (a && b) {\n        const units = [\"second\", \"minute\", \"hour\", \"day\", \"week\"];\n        const ai = units.indexOf(a.unit);\n        const bi = units.indexOf(b.unit);\n        if (ai < bi || (ai === bi && a.n <= b.n)) {\n          // ok\n        } else {\n          sorted = false;\n          break;\n        }\n      }\n    }\n    extractedData.sortedNewestFirst = sorted;\n\n    return {\n      success: sorted,\n      action: 'Clicked \"New\" tab and verified posts are sorted by newest first',\n      extractedData,\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 25851,
      "timestamp": "2025-09-15T12:20:53.612Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 76852,
  "timestamp": "2025-09-15T12:20:02.611Z",
  "savedAt": "2025-09-15T12:21:19.463Z",
  "version": "1.0"
}