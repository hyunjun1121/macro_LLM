{
  "id": "Threads_Sheet1_1757928320223_pw5h0_1757934838902",
  "website": "Threads",
  "task": {
    "id": "Sheet1_1757928320223_pw5h0",
    "description": "M002",
    "objective": "Rapidly Click Like Buttons",
    "expectedResult": "Click like buttons on all visible threads in rapid succession (within 5 seconds)",
    "difficulty": ".thread-action[data-action='like']",
    "category": 3,
    "tags": [
      "10 seconds"
    ],
    "notes": "Yes"
  },
  "websiteInfo": {
    "name": "Threads",
    "htmlFiles": [
      "index.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for threads feed to be visible (main content area)\n    await page.waitForSelector('#threads-feed', { state: 'visible', timeout: 5000 });\n\n    // Wait for at least one like button to appear\n    await page.waitForSelector(\".thread-action[data-action='like']\", { timeout: 5000 });\n\n    // Get all visible like buttons\n    const likeButtons = await page.$$eval(\n      \".thread-action[data-action='like']\",\n      (nodes) => nodes.filter(btn => btn.offsetParent !== null).map(btn => {\n        // Try to get thread id from ancestor or data attribute\n        let threadId = null;\n        let el = btn;\n        while (el && !threadId) {\n          if (el.dataset && el.dataset.threadId) threadId = el.dataset.threadId;\n          el = el.parentElement;\n        }\n        return {\n          selector: btn.getAttribute('data-action'),\n          threadId,\n          text: btn.textContent.trim()\n        };\n      })\n    );\n\n    // Click all visible like buttons in rapid succession (within 5 seconds)\n    // We'll click them as fast as possible, but also record which ones we click\n    let clickedThreadIds = [];\n    let clickedCount = 0;\n    const likeBtnHandles = await page.$$(\".thread-action[data-action='like']\");\n    for (const btnHandle of likeBtnHandles) {\n      // Only click if visible\n      const isVisible = await btnHandle.evaluate((el) => el.offsetParent !== null);\n      if (isVisible) {\n        await btnHandle.click();\n        clickedCount++;\n        // Try to extract thread id for verification\n        const threadId = await btnHandle.evaluate((el) => {\n          let id = null, node = el;\n          while (node && !id) {\n            if (node.dataset && node.dataset.threadId) id = node.dataset.threadId;\n            node = node.parentElement;\n          }\n          return id;\n        });\n        if (threadId) clickedThreadIds.push(threadId);\n      }\n    }\n\n    // Wait a short moment for UI to update\n    await page.waitForTimeout(800);\n\n    // Take screenshot after liking\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_likes.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_likes.png'));\n\n    // Extract the state of like buttons after clicking (to verify they are now \"liked\")\n    // We'll check if their class or icon changed, or if the like count increased\n    const likeStates = await page.$$eval(\n      \".thread-action[data-action='like']\",\n      (nodes) => nodes.filter(btn => btn.offsetParent !== null).map(btn => {\n        const ariaPressed = btn.getAttribute('aria-pressed');\n        const classList = btn.className;\n        const text = btn.textContent.trim();\n        // Try to extract like count if present (e.g., inside a span)\n        let likeCount = null;\n        const countEl = btn.querySelector('.like-count, .count, span');\n        if (countEl) {\n          likeCount = countEl.textContent.replace(/\\D/g, '');\n        }\n        return { ariaPressed, classList, text, likeCount };\n      })\n    );\n\n    return {\n      success: true,\n      action: `Clicked ${clickedCount} visible like buttons on threads in rapid succession.`,\n      extractedData: {\n        initialLikeButtons: likeButtons,\n        clickedThreadIds,\n        likeStatesAfter: likeStates\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 17529,
      "timestamp": "2025-09-15T11:13:58.902Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Wait for threads feed to be visible\n    await page.waitForSelector('#threads-feed', { timeout: 5000 });\n\n    // Take initial screenshot\n    const initialScreenshot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialScreenshot });\n    screenshots.push(initialScreenshot);\n\n    // Wait for at least one thread to load (by looking for a thread action bar)\n    await page.waitForSelector('.thread-action[data-action=\"like\"]', { timeout: 5000 });\n\n    // Ensure all visible like buttons are present\n    // Use XPath as alternate selector strategy to find buttons with a heart icon (FontAwesome 'fa-heart')\n    // This helps if data-action changes or is dynamic\n    // Only select visible ones\n    const likeButtons = await page.$$('xpath=//button[contains(@class, \"thread-action\") and (contains(@data-action, \"like\") or .//i[contains(@class, \"fa-heart\")]) and not(contains(@class, \"liked\")) and not(@aria-pressed=\"true\")]');\n\n    // If the above finds nothing, try fallback: select all thread-action[data-action='like'] that are visible\n    let buttonsToClick = likeButtons.filter(async btn => await btn.isVisible());\n    if (buttonsToClick.length === 0) {\n      // Fallback: CSS selector for not already liked\n      const altLikeButtons = await page.$$('.thread-action[data-action=\"like\"]:not(.liked)');\n      buttonsToClick = [];\n      for (const btn of altLikeButtons) {\n        if (await btn.isVisible()) buttonsToClick.push(btn);\n      }\n    }\n\n    // If still none, try another fallback: look for all .thread-action with a child i.fa-heart\n    if (buttonsToClick.length === 0) {\n      const allThreadActions = await page.$$('.thread-action');\n      for (const btn of allThreadActions) {\n        if (await btn.isVisible()) {\n          const hasHeart = await btn.$('i.fa-heart');\n          const isLiked = await btn.evaluate(el => el.classList.contains('liked') || el.getAttribute('aria-pressed') === 'true');\n          if (hasHeart && !isLiked) buttonsToClick.push(btn);\n        }\n      }\n    }\n\n    // Limit to those currently visible in the viewport\n    let visibleCount = 0;\n    for (const btn of buttonsToClick) {\n      if (await btn.isVisible()) visibleCount++;\n    }\n\n    // Click all visible like buttons in rapid succession (within 5 seconds)\n    const clickPromises = [];\n    let clickedCount = 0;\n    for (const btn of buttonsToClick) {\n      if (await btn.isVisible()) {\n        clickPromises.push(btn.click({ delay: 10 }));\n        clickedCount++;\n      }\n    }\n    // Wait for all to be clicked, but finish within 5 seconds\n    await Promise.race([\n      Promise.all(clickPromises),\n      new Promise(resolve => setTimeout(resolve, 5000))\n    ]);\n\n    // Take screenshot after clicking\n    const afterClickScreenshot = path.join(screenshotsDir, 'step_2_after_likes.png');\n    await page.screenshot({ path: afterClickScreenshot });\n    screenshots.push(afterClickScreenshot);\n\n    // Extract data: count of like buttons clicked & count of liked buttons after\n    // After clicking, liked buttons may have a .liked class or aria-pressed=\"true\"\n    const likedButtonsAfter = await page.$$eval(\n      '.thread-action[data-action=\"like\"].liked, .thread-action[data-action=\"like\"][aria-pressed=\"true\"]',\n      nodes => nodes.length\n    );\n\n    return {\n      success: true,\n      action: `Clicked all visible thread like buttons (${clickedCount}) in rapid succession.`,\n      extractedData: {\n        initiallyVisibleLikeButtons: visibleCount,\n        clickedLikeButtons: clickedCount,\n        likedButtonsAfter\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 24565,
      "timestamp": "2025-09-15T11:14:16.431Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('domcontentloaded');\n    const screenshots = [];\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the main threads feed to be visible\n    // Use an alternative selector strategy: look for the threads-feed container by its ID and a likely thread-item child\n    await page.waitForSelector('#threads-feed', { timeout: 5000 });\n\n    // Wait for at least one like button to appear using its aria-label or icon as alternative\n    // Try to find buttons: button/thread-action[data-action='like'] or with aria-label, or containing a heart icon\n    let likeButtons = await page.$$('.thread-action[data-action=\"like\"]');\n    if (likeButtons.length === 0) {\n      // Fallback: try to find buttons with a heart icon inside\n      likeButtons = await page.$$('button:has(svg.fa-heart), .thread-action:has(i.fa-heart)');\n    }\n\n    // One more fallback: query for all .thread-action and filter by data-action attribute\n    if (likeButtons.length === 0) {\n      likeButtons = await page.$$('.thread-action');\n      likeButtons = (await Promise.all(likeButtons.map(async btn => {\n        const action = await btn.getAttribute('data-action');\n        return action === 'like' ? btn : null;\n      }))).filter(Boolean);\n    }\n\n    // Take screenshot before clicking likes\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_likes.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_likes.png'));\n\n    // Click all visible like buttons in rapid succession (within 5 seconds)\n    const likeClickStart = Date.now();\n    let clickedCount = 0;\n    for (const btn of likeButtons) {\n      // Check if button is visible and enabled (not already liked)\n      const visible = await btn.isVisible();\n      const disabled = await btn.getAttribute('disabled');\n      if (visible && !disabled) {\n        await btn.click();\n        clickedCount++;\n      }\n      // Stop if 5 seconds elapsed\n      if (Date.now() - likeClickStart > 4900) break;\n    }\n\n    // Wait a bit for UI to update, then take screenshot\n    await page.waitForTimeout(600);\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_likes.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_likes.png'));\n\n    // Extract data: count the number of liked states (e.g., check if .thread-action[data-action='like'].active or has aria-pressed=true)\n    let likedCount = 0;\n    const likedButtons = await page.$$eval(\n      '.thread-action[data-action=\"like\"]',\n      nodes => nodes.filter(n =>\n        n.classList.contains('active') ||\n        n.getAttribute('aria-pressed') === 'true' ||\n        n.querySelector('.fa-heart')?.classList.contains('liked')\n      ).length\n    );\n    likedCount = likedButtons;\n\n    return {\n      success: true,\n      action: `Clicked all visible 'like' buttons on threads in rapid succession (${clickedCount} like buttons clicked).`,\n      extractedData: {\n        likeButtonsFound: likeButtons.length,\n        likeButtonsClicked: clickedCount,\n        likeButtonsNowActive: likedCount\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 29637,
      "timestamp": "2025-09-15T11:14:40.996Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 71731,
  "timestamp": "2025-09-15T11:13:58.902Z",
  "savedAt": "2025-09-15T11:15:10.633Z",
  "version": "1.0"
}