{
  "id": "Threads_Sheet1_1757928320247_1a811_1757934861450",
  "website": "Threads",
  "task": {
    "id": "Sheet1_1757928320247_1a811",
    "description": "M002",
    "objective": "Rapidly Click Like Buttons",
    "expectedResult": "Click like buttons on all visible threads in rapid succession (within 5 seconds)",
    "difficulty": ".thread-action[data-action='like']",
    "category": 3,
    "tags": [
      "10 seconds"
    ],
    "notes": "Yes"
  },
  "websiteInfo": {
    "name": "Threads",
    "htmlFiles": [
      "index.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the threads feed to be visible\n    await page.waitForSelector('#threads-feed', { timeout: 5000 });\n\n    // Wait for at least one thread like button to appear\n    await page.waitForSelector(\".thread-action[data-action='like']\", { timeout: 5000 });\n\n    // Get all visible like buttons for threads\n    const likeButtons = await page.$$eval(\n      \".thread-action[data-action='like']\",\n      (btns) =>\n        btns\n          .filter(\n            (btn) => btn.offsetParent !== null && !btn.classList.contains('liked')\n          )\n          .map((btn) => {\n            // Try to get a unique identifier for the thread\n            const threadItem = btn.closest('.thread-item');\n            return {\n              selector: btn.getAttribute('data-action'),\n              threadId: threadItem ? threadItem.getAttribute('data-thread-id') : null\n            };\n          })\n    );\n\n    // Click all visible like buttons in rapid succession (within 5 seconds)\n    const likeButtonHandles = await page.$$(\n      \".thread-action[data-action='like']\"\n    );\n\n    let clickedCount = 0;\n    const clickPromises = [];\n    const start = Date.now();\n\n    for (const btnHandle of likeButtonHandles) {\n      // Only click if visible and not already liked\n      const isVisible = await btnHandle.evaluate(\n        (el) => el.offsetParent !== null && !el.classList.contains('liked')\n      );\n      if (isVisible) {\n        clickPromises.push(btnHandle.click());\n        clickedCount++;\n      }\n    }\n\n    // Wait for all clicks to finish, but ensure it's within 5 seconds\n    await Promise.race([\n      Promise.all(clickPromises),\n      new Promise((resolve) => setTimeout(resolve, 5000)),\n    ]);\n\n    // Wait a moment for UI to update\n    await page.waitForTimeout(500);\n\n    // Take screenshot after liking\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_likes.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_likes.png'));\n\n    // Extract data: count how many threads are now liked (have .liked class)\n    const likedCount = await page.$$eval(\n      \".thread-action[data-action='like'].liked\",\n      (btns) => btns.length\n    );\n\n    // Optionally, extract thread IDs that are now liked\n    const likedThreadIds = await page.$$eval(\n      \".thread-action[data-action='like'].liked\",\n      (btns) =>\n        btns.map((btn) => {\n          const threadItem = btn.closest('.thread-item');\n          return threadItem ? threadItem.getAttribute('data-thread-id') : null;\n        }).filter(Boolean)\n    );\n\n    return {\n      success: true,\n      action: `Clicked like buttons on all visible threads in rapid succession (${clickedCount} attempted, ${likedCount} confirmed liked).`,\n      extractedData: {\n        attemptedLikes: clickedCount,\n        confirmedLiked: likedCount,\n        likedThreadIds\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 16404,
      "timestamp": "2025-09-15T11:14:21.450Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file and wait for network to be idle\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot of the home page\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Make sure we're on the \"Home\" view where threads are shown\n    // Use navigation text content and active class as alternate strategy\n    const homeNavSelector = \"//li[contains(@class,'nav-item') and .//span[normalize-space(text())='Home'] and contains(@class,'active')]\";\n    await page.waitForSelector('main.main-content');\n    // Only click if not already active\n    const homeNavIsActive = await page.$(homeNavSelector);\n    if (!homeNavIsActive) {\n      // Click on the Home tab\n      const homeTab = await page.$(\"//li[contains(@class,'nav-item') and .//span[normalize-space(text())='Home']]\");\n      if (homeTab) {\n        await homeTab.click();\n        await page.waitForTimeout(400); // Wait for view to update\n      }\n    }\n\n    // Wait for threads to be rendered in the feed\n    // Try a selector strategy using threads-feed + thread-item\n    const threadSelector = \"#threads-feed .thread-item\";\n    await page.waitForSelector(threadSelector, { timeout: 3000 });\n\n    // Wait a bit extra for all dynamic threads to load\n    await page.waitForTimeout(700);\n\n    // Get all visible thread \"Like\" buttons using alternative selector strategy:\n    // - Find buttons inside each .thread-item\n    // - Use aria-label or text content fallback, in case data-action changes\n    // Use page.$$ to get all like buttons\n    const likeButtonHandles = await page.$$(\n      \"#threads-feed .thread-item button.thread-action[data-action='like'], \" +\n      \"#threads-feed .thread-item .thread-action[aria-label*='Like'], \" +\n      \"#threads-feed .thread-item .thread-action[title*='Like']\"\n    );\n\n    // Filter only visible buttons (in case some are hidden due to scrolling or collapsed threads)\n    const visibleLikeButtons = [];\n    for (const handle of likeButtonHandles) {\n      const box = await handle.boundingBox();\n      if (box) visibleLikeButtons.push(handle);\n    }\n\n    // Record before-like counts for verification\n    const likeCountsBefore = [];\n    for (const btn of visibleLikeButtons) {\n      // Try to find the sibling element that shows number of likes\n      // Try parent, then next sibling, fallback to 0\n      let count = 0;\n      try {\n        const countText = await btn.evaluate(node => {\n          // Try to find number nearby (span or div)\n          let el = node.parentElement;\n          if (!el) return '';\n          // Look for .thread-action-likes or similar\n          let sibling = el.querySelector(\".thread-action-likes\") ||\n                        el.querySelector(\"[class*='like-count']\") ||\n                        el.nextElementSibling;\n          return sibling ? sibling.textContent : '';\n        });\n        count = parseInt((countText || '').replace(/\\D/g, '')) || 0;\n      } catch {}\n      likeCountsBefore.push(count);\n    }\n\n    // Click all visible like buttons as quickly as possible (in rapid succession)\n    // Use Promise.all for parallelization, but throttle to avoid UI glitches\n    const clickPromises = [];\n    for (const btn of visibleLikeButtons) {\n      clickPromises.push(btn.click());\n      // Small delay to simulate rapid, but not simultaneous, clicks\n      await page.waitForTimeout(100);\n    }\n\n    // Wait for all clicks to finish\n    await Promise.all(clickPromises);\n\n    // Wait a short moment for UI to update\n    await page.waitForTimeout(700);\n\n    // Take screenshot after liking all threads\n    const afterLikeShot = path.join(screenshotsDir, 'step_2_after_likes.png');\n    await page.screenshot({ path: afterLikeShot });\n    screenshots.push(afterLikeShot);\n\n    // Extract like counts after clicking\n    const likeCountsAfter = [];\n    for (const btn of visibleLikeButtons) {\n      let count = 0;\n      try {\n        const countText = await btn.evaluate(node => {\n          let el = node.parentElement;\n          if (!el) return '';\n          let sibling = el.querySelector(\".thread-action-likes\") ||\n                        el.querySelector(\"[class*='like-count']\") ||\n                        el.nextElementSibling;\n          return sibling ? sibling.textContent : '';\n        });\n        count = parseInt((countText || '').replace(/\\D/g, '')) || 0;\n      } catch {}\n      likeCountsAfter.push(count);\n    }\n\n    // Count how many likes increased (sanity check)\n    let likeIncrements = 0;\n    for (let i = 0; i < likeCountsAfter.length; ++i) {\n      if (likeCountsAfter[i] > likeCountsBefore[i]) likeIncrements++;\n    }\n\n    return {\n      success: true,\n      action: `Clicked all visible thread Like buttons (${visibleLikeButtons.length}) in rapid succession.`,\n      extractedData: {\n        likeCountsBefore,\n        likeCountsAfter,\n        likeIncrements,\n        totalLikeButtonsFound: visibleLikeButtons.length\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 20658,
      "timestamp": "2025-09-15T11:14:37.854Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Ensure home view is active (by visible h2 \"Home\" in main-content area)\n    await page.waitForSelector('.main-content .view.active h2', { timeout: 4000 });\n    // Wait for threads-feed to be present and visible\n    await page.waitForSelector('#threads-feed', { timeout: 4000, state: 'visible' });\n\n    // Wait for at least one thread action bar to appear (threads are likely rendered dynamically)\n    await page.waitForSelector(\".thread-action[data-action='like']\", { timeout: 5000 });\n\n    // Use a different selector approach: find all visible like buttons using xpath that matches the icon or tooltip\n    // Also filter only visible ones\n    const likeButtons = await page.$$('xpath=//button[contains(@class,\"thread-action\") and @data-action=\"like\" and not(contains(@class,\"disabled\"))]');\n\n    // For verification, collect the count of like buttons before clicking\n    const likeButtonCount = likeButtons.length;\n\n    // Click all visible like buttons rapidly (within 5 seconds)\n    const clickPromises = [];\n    for (const btn of likeButtons) {\n      // Double-check if visible (some may be offscreen or hidden)\n      const isVisible = await btn.isVisible();\n      if (isVisible) {\n        clickPromises.push(btn.click());\n      }\n    }\n    await Promise.all(clickPromises);\n\n    // Wait a short moment to allow UI to update (for like state change)\n    await page.waitForTimeout(700);\n\n    // Take a screenshot after clicking likes\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_likes_clicked.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_likes_clicked.png'));\n\n    // For verification: extract number of liked threads (after clicking)\n    // The app may update the 'isLiked' state visually - let's check for a CSS change: e.g., a class 'liked' or aria-pressed=\"true\".\n    // We'll look for buttons with 'data-action=\"like\"' and aria-pressed=\"true\" (common pattern), or with a 'liked' class\n    const likedCount = await page.evaluate(() => {\n      const likedByAria = Array.from(document.querySelectorAll('.thread-action[data-action=\"like\"][aria-pressed=\"true\"]')).length;\n      const likedByClass = Array.from(document.querySelectorAll('.thread-action[data-action=\"like\"].liked')).length;\n      // fallback: count total like buttons if no state change\n      const buttons = document.querySelectorAll('.thread-action[data-action=\"like\"]');\n      return {\n        likedByAria,\n        likedByClass,\n        totalLikeButtons: buttons.length\n      };\n    });\n\n    return {\n      success: true,\n      action: \"Clicked all visible like buttons on threads feed using alternate selectors and strategies.\",\n      extractedData: {\n        likeButtonCount,\n        likedCount\n      },\n      screenshots,\n      error: null\n    };\n\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 24894,
      "timestamp": "2025-09-15T11:14:58.512Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 61956,
  "timestamp": "2025-09-15T11:14:21.450Z",
  "savedAt": "2025-09-15T11:15:23.406Z",
  "version": "1.0"
}