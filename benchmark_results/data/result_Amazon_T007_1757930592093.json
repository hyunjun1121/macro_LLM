{
  "id": "Amazon_T007_1757930592093",
  "website": "Amazon",
  "task": {
    "id": "T007",
    "description": "Apply Price Sort Filter",
    "objective": "General",
    "expectedResult": "Medium",
    "difficulty": "Search for products, then use the sort dropdown to sort by 'Price: Low to High'.",
    "category": "#sortSelect, .products-grid .product-card",
    "tags": [
      "1. Perform product search 2. Find sort dropdown 3. Select 'Price: Low to High' option"
    ],
    "notes": "Products reorder by ascending price, first product has lowest visible price, notification confirms sort applied"
  },
  "websiteInfo": {
    "name": "Amazon",
    "htmlFiles": [
      "index.html",
      "test_website.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Step 2: Enter a search term (e.g., \"phone\") in the search input and submit\n    await page.waitForSelector('#searchInput', { timeout: 5000 });\n    await page.fill('#searchInput', 'phone');\n    // Click the search button\n    await page.waitForSelector('button.search-btn', { timeout: 5000 });\n    await page.click('button.search-btn');\n\n    // Wait for products grid to appear\n    await page.waitForSelector('.products-grid .product-card', { timeout: 7000 });\n\n    // Take screenshot after search\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_search.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_search.png'));\n\n    // Step 3: Locate the sort dropdown (assume #sortSelect or select.sort-select)\n    // Try both selectors for robustness\n    let sortDropdown = null;\n    try {\n      sortDropdown = await page.waitForSelector('#sortSelect', { timeout: 2000 });\n    } catch {\n      try {\n        sortDropdown = await page.waitForSelector('select.sort-select', { timeout: 2000 });\n      } catch {\n        // Try to find a select element with price sort options\n        const selects = await page.$$('select');\n        for (const sel of selects) {\n          const options = await sel.$$eval('option', opts => opts.map(o => o.textContent));\n          if (options.some(o => o && o.toLowerCase().includes('price'))) {\n            sortDropdown = sel;\n            break;\n          }\n        }\n      }\n    }\n\n    if (!sortDropdown) {\n      throw new Error('Sort dropdown not found');\n    }\n\n    // Step 4: Select \"Price: Low to High\" option\n    // Find the value for \"Price: Low to High\"\n    const options = await sortDropdown.$$eval('option', opts =>\n      opts.map(o => ({ value: o.value, text: o.textContent.trim() }))\n    );\n    const priceLowToHigh = options.find(\n      o => o.text.toLowerCase().includes('price') && o.text.toLowerCase().includes('low')\n    );\n    if (!priceLowToHigh) {\n      throw new Error('Price: Low to High option not found in sort dropdown');\n    }\n    await sortDropdown.selectOption(priceLowToHigh.value);\n\n    // Wait for products to update (assume some loading or DOM change)\n    await page.waitForTimeout(1200); // fallback for DOM update\n\n    // Take screenshot after applying sort\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_sort.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_sort.png'));\n\n    // Step 5: Extract product prices to verify sorting\n    const prices = await page.$$eval('.products-grid .product-card', cards => {\n      return cards.map(card => {\n        const priceEl = card.querySelector('.price, .product-price, [class*=price]');\n        if (priceEl) {\n          // Remove currency symbols and commas\n          const num = priceEl.textContent.replace(/[^0-9.,]/g, '').replace(',', '');\n          return parseFloat(num);\n        }\n        return null;\n      }).filter(Boolean);\n    });\n\n    // Check if prices are sorted ascending\n    let sorted = false;\n    if (prices.length > 1) {\n      sorted = prices.every((v, i, arr) => i === 0 || arr[i - 1] <= v);\n    }\n\n    return {\n      success: sorted,\n      action: \"Searched for products and applied 'Price: Low to High' sort filter\",\n      extractedData: {\n        prices,\n        sortedAscending: sorted\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 50242,
      "timestamp": "2025-09-15T10:03:12.093Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Step 1: Initial screenshot (homepage)\n    const screenshots = [];\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Step 2: Search for products (use the placeholder text as an anchor for the input)\n    const searchInputSelector = 'input[placeholder=\"Search Amazon\"]';\n    await page.waitForSelector(searchInputSelector, { timeout: 5000 });\n    await page.fill(searchInputSelector, 'laptop');\n    // Use button with icon and adjacent to search input\n    const searchButtonSelector = '.search-container button.search-btn';\n    await page.waitForSelector(searchButtonSelector, { timeout: 3000 });\n    await page.click(searchButtonSelector);\n\n    // Wait for products grid to appear (look for .products-grid or at least one .product-card)\n    const productCardSelector = '.products-grid .product-card, .product-card';\n    await page.waitForSelector(productCardSelector, { timeout: 5000 });\n\n    // Step 3: Screenshot after search\n    const afterSearchShot = path.join(screenshotsDir, 'step_2_after_search.png');\n    await page.screenshot({ path: afterSearchShot });\n    screenshots.push(afterSearchShot);\n\n    // Step 4: Locate and interact with the sort dropdown\n    // Try a variety of selectors for robustness\n    // - Look for a select element containing options with \"Price: Low to High\"\n    const sortDropdown = await page.$('select:has-text(\"Price\")');\n    let sortSelector;\n    if (sortDropdown) {\n      sortSelector = await sortDropdown.evaluateHandle(node => node);\n    } else {\n      // fallback: any select (assuming only one sort select visible after search)\n      sortSelector = await page.$('select');\n    }\n\n    if (!sortSelector) throw new Error('Sort dropdown not found');\n\n    // Find the option for \"Price: Low to High\"\n    // Try by option text, fallback to value\n    const options = await page.$$eval(\n      'select option',\n      opts => opts.map(opt => ({ value: opt.value, text: opt.textContent.trim() }))\n    );\n    const priceLowOption = options.find(\n      o => o.text.toLowerCase().includes('price') && o.text.toLowerCase().includes('low')\n    );\n    if (!priceLowOption)\n      throw new Error('No \"Price: Low to High\" sort option found in sort select');\n\n    // Select the found option\n    await page.selectOption('select', { label: priceLowOption.text });\n\n    // Wait for sort to take effect: wait for possible loading indicator or content update.\n    // For robustness, re-wait for .product-card and a short pause.\n    await page.waitForTimeout(600); // let DOM update\n    await page.waitForSelector(productCardSelector, { timeout: 5000 });\n\n    // Step 5: Screenshot after sort applied\n    const afterSortShot = path.join(screenshotsDir, 'step_3_after_sort.png');\n    await page.screenshot({ path: afterSortShot });\n    screenshots.push(afterSortShot);\n\n    // Step 6: Extract product prices from the grid to verify sorting\n    // Target first 5 product cards\n    const priceData = await page.$$eval(\n      '.products-grid .product-card, .product-card',\n      cards =>\n        cards.slice(0, 5).map(card => {\n          // Find price element robustly: look for $ sign in textContent\n          const priceNode =\n            card.querySelector('.price') ||\n            Array.from(card.querySelectorAll('*')).find(n =>\n              /\\$\\d/.test(n.textContent)\n            );\n          if (!priceNode) return null;\n          const priceText = priceNode.textContent.replace(/[^0-9.,]/g, '');\n          return parseFloat(priceText.replace(/,/g, ''));\n        })\n    );\n    // Only keep numeric values\n    const filteredPrices = priceData.filter(x => typeof x === 'number' && !isNaN(x));\n\n    // Check if the prices are in ascending order\n    let sorted = true;\n    for (let i = 1; i < filteredPrices.length; i++) {\n      if (filteredPrices[i] < filteredPrices[i - 1]) sorted = false;\n    }\n\n    return {\n      success: true,\n      action:\n        'Searched for products and applied the \"Price: Low to High\" sort filter using the dropdown. Verified product prices are sorted ascending.',\n      extractedData: {\n        first5Prices: filteredPrices,\n        ascending: sorted\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 56239,
      "timestamp": "2025-09-15T10:04:02.335Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Enter a search term (use 'phone' as a common product)\n    const searchInputSelector = 'input#searchInput, input.search-input, [placeholder=\"Search Amazon\"]';\n    await page.waitForSelector(searchInputSelector, { timeout: 5000 });\n    // Clear input in case of autofill\n    await page.fill(searchInputSelector, '');\n    await page.type(searchInputSelector, 'phone', { delay: 100 });\n\n    // Click the search button (using aria-label, icon, and button)\n    const searchBtnSelector = 'button.search-btn, button:has(i.fa-search), button:has-text(\"Search\")';\n    await page.waitForSelector(searchBtnSelector, { timeout: 5000 });\n    await page.click(searchBtnSelector);\n\n    // Wait for products grid to load (use .products-grid or .product-card)\n    await page.waitForSelector('.products-grid .product-card, .product-card', { timeout: 7000 });\n\n    // Take screenshot after search\n    const searchShot = path.join(screenshotsDir, 'step_2_search_results.png');\n    await page.screenshot({ path: searchShot });\n    screenshots.push(searchShot);\n\n    // Look for the sort dropdown: try id, class, label, and xpath\n    // Common select: select[name*=\"sort\"], select.sort-select, select#sortSelect, select:has(option:has-text(\"Price: Low to High\"))\n    let sortDropdownSelector = null;\n    // Try several selectors for robustness\n    const possibleSortSelectors = [\n      'select#sortSelect',\n      'select.sort-select',\n      'select[name=\"sort\"]',\n      'select:has(option:text(\"Price: Low to High\"))',\n      '//select[option[contains(text(), \"Price: Low to High\")]]'\n    ];\n\n    for (const sel of possibleSortSelectors) {\n      try {\n        await page.waitForSelector(sel, { timeout: 2000 });\n        sortDropdownSelector = sel;\n        break;\n      } catch (_) {}\n    }\n\n    // If none of the above, try to find by label\n    if (!sortDropdownSelector) {\n      const labelHandles = await page.$$('label');\n      for (const label of labelHandles) {\n        const text = await label.evaluate(el => el.textContent || '');\n        if (text.toLowerCase().includes('sort') || text.toLowerCase().includes('price')) {\n          const forAttr = await label.getAttribute('for');\n          if (forAttr) {\n            sortDropdownSelector = `#${forAttr}`;\n            break;\n          }\n        }\n      }\n    }\n\n    // If still not found, fallback to a generic select after/before products grid\n    if (!sortDropdownSelector) {\n      const genericSelects = await page.$$('select');\n      for (const selHandle of genericSelects) {\n        const options = await selHandle.$$('option');\n        for (const opt of options) {\n          const val = await opt.evaluate(n => n.textContent || '');\n          if (val.toLowerCase().includes('price: low')) {\n            sortDropdownSelector = await selHandle.evaluate((el) => {\n              // Find a unique selector for this select\n              if (el.id) return `#${el.id}`;\n              if (el.className) return `.${el.className.split(' ').join('.')}`;\n              return 'select';\n            });\n            break;\n          }\n        }\n        if (sortDropdownSelector) break;\n      }\n    }\n\n    // If still not found, throw error\n    if (!sortDropdownSelector) {\n      throw new Error('Sort dropdown could not be found with reasonable selectors.');\n    }\n\n    // Open the dropdown and select 'Price: Low to High'\n    // Wait for dropdown to be visible\n    await page.waitForSelector(sortDropdownSelector, { timeout: 4000 });\n    // Find the exact value for the 'Price: Low to High' option\n    const options = await page.$$(sortDropdownSelector + ' > option');\n    let priceLowValue = null;\n    for (const opt of options) {\n      const text = await opt.evaluate(node => node.textContent || '');\n      if (text.trim().toLowerCase().includes('price: low')) {\n        priceLowValue = await opt.evaluate(node => node.value);\n        break;\n      }\n    }\n    if (!priceLowValue) {\n      // Try to select by visible text fallback\n      await page.selectOption(sortDropdownSelector, { label: /price:\\s*low/i });\n    } else {\n      await page.selectOption(sortDropdownSelector, priceLowValue);\n    }\n\n    // Wait for products grid to update (wait for network or a product card to change)\n    await page.waitForTimeout(1200); // Allow JS to update grid\n    await page.waitForSelector('.products-grid .product-card, .product-card', { timeout: 8000 });\n\n    // Take screenshot after applying sort\n    const sortShot = path.join(screenshotsDir, 'step_3_sorted_low_to_high.png');\n    await page.screenshot({ path: sortShot });\n    screenshots.push(sortShot);\n\n    // Extract product titles and prices to verify sorting\n    // Try to get the first 5 product cards\n    const productCards = await page.$$('.products-grid .product-card, .product-card');\n    const extractedProducts = [];\n    for (let i = 0; i < Math.min(5, productCards.length); i++) {\n      const card = productCards[i];\n      let title = '';\n      let price = '';\n      // Try various title/price selectors inside the card\n      const titleHandle = await card.$('h2, .product-title, [data-testid=\"product-title\"], .title, a');\n      if (titleHandle) {\n        title = (await titleHandle.evaluate(el => el.textContent)).trim();\n      }\n      const priceHandle = await card.$('.price, .product-price, [data-testid=\"product-price\"], span:has-text(\"$\")');\n      if (priceHandle) {\n        price = (await priceHandle.evaluate(el => el.textContent)).replace(/[^\\d.,]/g, '').trim();\n      }\n      extractedProducts.push({ title, price });\n    }\n\n    // Check if the prices are sorted in ascending order (for validation)\n    const priceNumbers = extractedProducts\n      .map(p => Number((p.price || '0').replace(/,/g, '').replace(/[^0-9.]/g, '')))\n      .filter(n => !isNaN(n) && n > 0);\n    let sorted = false;\n    if (priceNumbers.length > 1) {\n      sorted = priceNumbers.every((v, idx, arr) => idx === 0 || v >= arr[idx - 1]);\n    }\n\n    return {\n      success: sorted,\n      action: \"Searched for 'phone', applied 'Price: Low to High' sort filter, and verified product order.\",\n      extractedData: {\n        sortDropdownSelector,\n        selectedSortValue: priceLowValue,\n        extractedProducts,\n        priceNumbers,\n        sortedAscending: sorted\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 60706,
      "timestamp": "2025-09-15T10:04:58.574Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 167187,
  "timestamp": "2025-09-15T10:03:12.093Z",
  "savedAt": "2025-09-15T10:05:59.280Z",
  "version": "1.0"
}