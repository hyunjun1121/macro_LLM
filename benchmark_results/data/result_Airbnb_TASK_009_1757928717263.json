{
  "id": "Airbnb_TASK_009_1757928717263",
  "website": "Airbnb",
  "task": {
    "id": "TASK_009",
    "description": "General",
    "objective": "Search History Storage",
    "expectedResult": "검색 수행 후 localStorage의 검색 기록이 업데이트되는지 확인하고 최신 검색어 추출하기",
    "difficulty": "Medium",
    "category": ".search-btn, localStorage",
    "tags": [
      "Search execution",
      "storage inspection"
    ],
    "notes": "localStorage의 airbnb_searches 배열에서 가장 최근 검색 기록"
  },
  "websiteInfo": {
    "name": "Airbnb",
    "htmlFiles": [
      "experiences.html",
      "host-dashboard.html",
      "index.html",
      "profile.html",
      "property.html",
      "trips.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the location input to be visible\n    await page.waitForSelector('#locationInput', { timeout: 5000 });\n\n    // Type a search term into the location input\n    const searchTerm = 'Seoul';\n    await page.fill('#locationInput', searchTerm);\n\n    // Optionally fill check-in and check-out dates (if required for search to work)\n    // We'll fill today's date and tomorrow for simplicity\n    const today = new Date();\n    const yyyy = today.getFullYear();\n    const mm = String(today.getMonth() + 1).padStart(2, '0');\n    const dd = String(today.getDate()).padStart(2, '0');\n    const tomorrow = new Date(today.getTime() + 24*60*60*1000);\n    const yyyy2 = tomorrow.getFullYear();\n    const mm2 = String(tomorrow.getMonth() + 1).padStart(2, '0');\n    const dd2 = String(tomorrow.getDate()).padStart(2, '0');\n    const checkin = `${yyyy}-${mm}-${dd}`;\n    const checkout = `${yyyy2}-${mm2}-${dd2}`;\n    await page.fill('#checkinInput', checkin);\n    await page.fill('#checkoutInput', checkout);\n\n    // Wait for the search button (try multiple selectors)\n    let searchBtn = await page.$('.search-btn');\n    if (!searchBtn) {\n      // Try to find by text if class is missing\n      searchBtn = await page.$('button:has-text(\"Search\")');\n    }\n    if (!searchBtn) {\n      // Try a generic button in search bar (fallback)\n      const searchBar = await page.$('.search-bar');\n      if (searchBar) {\n        const buttons = await searchBar.$$('button');\n        if (buttons.length > 0) {\n          searchBtn = buttons[buttons.length - 1];\n        }\n      }\n    }\n    if (!searchBtn) throw new Error('Search button not found');\n\n    // Click the search button\n    await searchBtn.click();\n\n    // Wait for possible search results or UI update (simulate network delay)\n    await page.waitForTimeout(1200);\n\n    // Take screenshot after search\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_search.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_search.png'));\n\n    // Extract localStorage search history\n    const searchHistory = await page.evaluate(() => {\n      // Try common keys for search history\n      const keys = Object.keys(window.localStorage);\n      let foundKey = null;\n      for (const k of keys) {\n        if (k.toLowerCase().includes('search') && k.toLowerCase().includes('history')) {\n          foundKey = k;\n          break;\n        }\n      }\n      if (!foundKey) {\n        // Try just 'searchHistory'\n        if (window.localStorage.getItem('searchHistory')) {\n          foundKey = 'searchHistory';\n        }\n      }\n      if (foundKey) {\n        try {\n          return JSON.parse(window.localStorage.getItem(foundKey));\n        } catch (e) {\n          return window.localStorage.getItem(foundKey);\n        }\n      }\n      // Try airbnbData.storageUtils if available (from script.js)\n      if (window.airbnbData && window.airbnbData.storageUtils && window.airbnbData.storageUtils.getSearchHistory) {\n        return window.airbnbData.storageUtils.getSearchHistory();\n      }\n      return null;\n    });\n\n    // Take screenshot of localStorage (for evidence)\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_localstorage.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_localstorage.png'));\n\n    // Extract the latest search term from searchHistory\n    let latestSearch = null;\n    if (Array.isArray(searchHistory) && searchHistory.length > 0) {\n      latestSearch = searchHistory[searchHistory.length - 1];\n    } else if (searchHistory && typeof searchHistory === 'object') {\n      // If it's an object, try to find a recent entry\n      const values = Object.values(searchHistory);\n      if (values.length > 0) {\n        latestSearch = values[values.length - 1];\n      }\n    } else if (typeof searchHistory === 'string') {\n      // If it's a string, just return it\n      latestSearch = searchHistory;\n    }\n\n    return {\n      success: true,\n      action: \"Performed a search, verified localStorage search history is updated, and extracted the latest search term.\",\n      extractedData: {\n        searchHistory,\n        latestSearch\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 18233,
      "timestamp": "2025-09-15T09:31:57.263Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n    await page.waitForSelector('#locationInput', { timeout: 7000 });\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // 1. Enter a search term in the location input\n    const locationInput = await page.$('#locationInput');\n    if (!locationInput) throw new Error('Location input not found');\n    await locationInput.click({ clickCount: 3 });\n    await locationInput.type('Seoul');\n    // Wait for debounce/input\n    await page.waitForTimeout(500);\n\n    // 2. Enter check-in and check-out dates if possible (optional, for completeness)\n    const today = new Date();\n    const checkinDate = today.toISOString().substring(0, 10);\n    const checkoutDate = new Date(today.getTime() + 86400000 * 3).toISOString().substring(0, 10);\n\n    const checkinInput = await page.$('#checkinInput');\n    if (checkinInput) {\n      await checkinInput.fill(checkinDate);\n      await page.waitForTimeout(200);\n    }\n    const checkoutInput = await page.$('#checkoutInput');\n    if (checkoutInput) {\n      await checkoutInput.fill(checkoutDate);\n      await page.waitForTimeout(200);\n    }\n\n    // 3. Find and click the search button using alternative selector strategies (text content and XPath)\n    let searchBtn = await page.$('.search-btn');\n    if (!searchBtn) {\n      // Try XPath as alternative, looking for button with 'Search' text\n      searchBtn = await page.$('//button[contains(., \"Search\")]');\n    }\n    if (!searchBtn) {\n      // Try by role and text\n      searchBtn = await page.getByRole\n        ? await page.getByRole('button', { name: /search/i })\n        : null;\n    }\n    if (!searchBtn) throw new Error('Search button not found');\n    await searchBtn.click();\n\n    // Wait for any dynamic updates (search results/listings updating, etc.)\n    await page.waitForTimeout(1500);\n\n    // Screenshot after search\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_search.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_search.png'));\n\n    // 4. Extract localStorage search history\n    // Try to find the key that contains search history\n    const localStorageData = await page.evaluate(() => {\n      const keys = Object.keys(window.localStorage);\n      // Try to find a key that might contain search history\n      let historyKey = keys.find(k => k.toLowerCase().includes('search'));\n      let history = null;\n      if (historyKey) {\n        try {\n          history = JSON.parse(window.localStorage.getItem(historyKey));\n        } catch (e) {\n          history = window.localStorage.getItem(historyKey);\n        }\n      }\n      return { keys, historyKey, history };\n    });\n\n    // 5. Extract latest search term from localStorage history\n    let latestSearch = null;\n    if (localStorageData.history) {\n      if (Array.isArray(localStorageData.history)) {\n        latestSearch = localStorageData.history[0] || null;\n      } else if (typeof localStorageData.history === 'object' && localStorageData.history !== null) {\n        // Try to get the latest by timestamp or first key\n        const values = Object.values(localStorageData.history);\n        latestSearch = values[0] || null;\n      } else if (typeof localStorageData.history === 'string') {\n        latestSearch = localStorageData.history;\n      }\n    }\n\n    // Screenshot after extraction for verification\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_localstorage.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_localstorage.png'));\n\n    return {\n      success: true,\n      action: \"Performed a search and verified that localStorage search history was updated; extracted the latest search term.\",\n      extractedData: {\n        localStorageKeys: localStorageData.keys,\n        searchHistoryKey: localStorageData.historyKey,\n        searchHistoryValue: localStorageData.history,\n        latestSearchTerm: latestSearch\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 21172,
      "timestamp": "2025-09-15T09:32:15.496Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the search bar input to appear (try ID selector first)\n    await page.waitForSelector('#locationInput', { timeout: 5000 });\n\n    // Enter a sample search query (use a unique value to verify later)\n    const searchQuery = 'Seoul';\n    await page.fill('#locationInput', searchQuery);\n\n    // Take screenshot after filling location\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_location_filled.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_location_filled.png'));\n\n    // Fill check-in and check-out dates (use today's date and tomorrow)\n    const today = new Date();\n    const yyyy = today.getFullYear();\n    const mm = String(today.getMonth() + 1).padStart(2, '0');\n    const dd = String(today.getDate()).padStart(2, '0');\n    const tomorrow = new Date(today);\n    tomorrow.setDate(today.getDate() + 1);\n    const tmm = String(tomorrow.getMonth() + 1).padStart(2, '0');\n    const tdd = String(tomorrow.getDate()).padStart(2, '0');\n    const checkinDate = `${yyyy}-${mm}-${dd}`;\n    const checkoutDate = `${tomorrow.getFullYear()}-${tmm}-${tdd}`;\n\n    await page.fill('#checkinInput', checkinDate);\n    await page.fill('#checkoutInput', checkoutDate);\n\n    // Optionally set guests (open menu, increment adults)\n    const guestBtn = await page.$('button.guest-selector');\n    if (guestBtn) {\n      await guestBtn.click();\n      // Wait for guest menu to show up (by ID)\n      await page.waitForSelector('#guestMenu', { state: 'visible', timeout: 2000 }).catch(() => {});\n      // Try to increment adults (+) button (using xpath as alternative)\n      const plusAdultBtn = await page.$('//div[@id=\"guestMenu\"]//strong[contains(text(),\"Adults\")]/ancestor::div[contains(@class,\"guest-option\")]//button[contains(text(),\"+\")]');\n      if (plusAdultBtn) {\n        await plusAdultBtn.click();\n      }\n    }\n\n    // Take screenshot after filling everything\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_all_fields_filled.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_all_fields_filled.png'));\n\n    // Find and click the search button\n    // Try multiple strategies: .search-btn, text=Search, or a button at the end of the search bar\n    let searchBtn = await page.$('.search-btn');\n    if (!searchBtn) {\n      searchBtn = await page.$('button:has-text(\"Search\")');\n    }\n    if (!searchBtn) {\n      // Fallback: find the last button in the search bar section\n      const searchBar = await page.$('.search-bar');\n      if (searchBar) {\n        const buttons = await searchBar.$$('button');\n        searchBtn = buttons[buttons.length - 1];\n      }\n    }\n    if (!searchBtn) {\n      throw new Error('Search button not found with any selector');\n    }\n\n    await searchBtn.click();\n\n    // Wait for possible search results or UI update (give some time for scripts to execute)\n    await page.waitForTimeout(1200);\n\n    // Take screenshot after search\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_4_after_search.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_4_after_search.png'));\n\n    // Extract the localStorage search history directly from the page\n    // Try to get all keys, and look for a likely key (e.g. \"searchHistory\" or similar)\n    const searchHistory = await page.evaluate(() => {\n      const result = {};\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        result[key] = localStorage.getItem(key);\n      }\n      // Try to parse a likely search history object\n      let parsed = null;\n      for (const [k, v] of Object.entries(result)) {\n        if (k.toLowerCase().includes('search') && v) {\n          try {\n            const arr = JSON.parse(v);\n            if (Array.isArray(arr)) parsed = arr;\n          } catch(e) {}\n        }\n      }\n      return {\n        allLocalStorage: result,\n        searchHistoryArray: parsed\n      };\n    });\n\n    // Find the most recent search entry if available\n    let latestSearch = null;\n    if (searchHistory.searchHistoryArray && searchHistory.searchHistoryArray.length > 0) {\n      latestSearch = searchHistory.searchHistoryArray[searchHistory.searchHistoryArray.length - 1];\n    }\n\n    return {\n      success: true,\n      action: \"Performed a search, verified that localStorage search history was updated, and extracted the latest search entry.\",\n      extractedData: {\n        allLocalStorage: searchHistory.allLocalStorage,\n        searchHistoryArray: searchHistory.searchHistoryArray,\n        latestSearch\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 27210,
      "timestamp": "2025-09-15T09:32:36.668Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 66615,
  "timestamp": "2025-09-15T09:31:57.263Z",
  "savedAt": "2025-09-15T09:33:03.878Z",
  "version": "1.0"
}