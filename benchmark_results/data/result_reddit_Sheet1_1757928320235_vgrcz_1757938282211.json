{
  "id": "reddit_Sheet1_1757928320235_vgrcz_1757938282211",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320235_vgrcz",
    "description": 8,
    "objective": "Regular",
    "expectedResult": "Save first post",
    "difficulty": "Easy",
    "category": "Click save button on first post and verify it's marked as saved",
    "tags": [
      ".post:first-child .post-action.saved"
    ],
    "notes": "toggleSavePost() saveDataToStorage()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the posts container to appear (main feed is likely in the center column)\n    // Try to find the first post by searching for a post title\n    // Use a generic selector for post title (e.g., h3, or a post container)\n    const firstPostTitleSelector = 'main .post-list .post, .main-container .post, article.post, div.post, [class*=post]';\n    let firstPost;\n    // Try several strategies to locate the first post\n    const possiblePostSelectors = [\n      'main .post-list .post',\n      '.main-container .post',\n      'article.post',\n      'div.post',\n      '[class*=post]'\n    ];\n    for (const sel of possiblePostSelectors) {\n      const post = await page.$(sel);\n      if (post) {\n        firstPost = post;\n        break;\n      }\n    }\n    // Fallback: find by post title text\n    if (!firstPost) {\n      const h3s = await page.$$('h3');\n      if (h3s.length > 0) {\n        firstPost = await h3s[0].evaluateHandle(node => node.closest('div,article,section'));\n      }\n    }\n\n    if (!firstPost) throw new Error('Could not locate the first post.');\n\n    // Within the first post, look for a \"Save\" button\n    // Try to find a button with text \"Save\" or an icon with title/aria-label \"Save\"\n    let saveButton = await firstPost.$('button:has-text(\"Save\")');\n    if (!saveButton) {\n      // Try aria-label\n      saveButton = await firstPost.$('button[aria-label*=\"Save\" i]');\n    }\n    if (!saveButton) {\n      // Try icon or span\n      saveButton = await firstPost.$('span:has-text(\"Save\")');\n      if (saveButton) {\n        // Get the closest button ancestor\n        saveButton = await saveButton.evaluateHandle(node => node.closest('button'));\n      }\n    }\n    if (!saveButton) {\n      // Try XPath as last resort\n      const [btn] = await firstPost.$x('.//button[contains(., \"Save\") or contains(@aria-label, \"Save\")]');\n      if (btn) saveButton = btn;\n    }\n    if (!saveButton) throw new Error('Could not locate the Save button on the first post.');\n\n    // Take screenshot before clicking Save\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_save.png'));\n\n    // Click the Save button\n    await saveButton.click();\n\n    // Wait for the Save button to change state (e.g., text changes to \"Saved\" or button is highlighted)\n    // Try to detect the change\n    let savedStateDetected = false;\n    let savedButtonText = '';\n    for (let i = 0; i < 10; i++) {\n      // Wait a bit\n      await page.waitForTimeout(300);\n      // Re-query the button\n      let savedBtn = await firstPost.$('button:has-text(\"Saved\")');\n      if (!savedBtn) {\n        // Try aria-label\n        savedBtn = await firstPost.$('button[aria-label*=\"Saved\" i]');\n      }\n      if (!savedBtn) {\n        // Try span text\n        savedBtn = await firstPost.$('span:has-text(\"Saved\")');\n        if (savedBtn) {\n          savedBtn = await savedBtn.evaluateHandle(node => node.closest('button'));\n        }\n      }\n      if (!savedBtn) {\n        // Try XPath\n        const [btn] = await firstPost.$x('.//button[contains(., \"Saved\") or contains(@aria-label, \"Saved\")]');\n        if (btn) savedBtn = btn;\n      }\n      if (savedBtn) {\n        savedStateDetected = true;\n        // Extract the button text for reporting\n        savedButtonText = await savedBtn.innerText();\n        break;\n      }\n    }\n\n    // Take screenshot after clicking Save\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_save.png'));\n\n    // Extract the post title for reporting\n    let postTitle = '';\n    const h3 = await firstPost.$('h3');\n    if (h3) {\n      postTitle = await h3.innerText();\n    }\n\n    return {\n      success: savedStateDetected,\n      action: savedStateDetected\n        ? \"Clicked Save on the first post and verified it is marked as saved.\"\n        : \"Clicked Save on the first post but could not verify saved state.\",\n      extractedData: {\n        postTitle,\n        savedButtonText,\n        savedStateDetected\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 37228,
      "timestamp": "2025-09-15T12:11:22.211Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    const screenshots = [];\n    // Take initial screenshot\n    const step1 = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: step1 });\n    screenshots.push(step1);\n\n    // Wait for the main feed to appear by waiting for a known post title from postsData\n    // Use text selector for the first post's title (from postsData JS: \"Just built my first React app! What do you think?\")\n    const firstPostTitle = \"Just built my first React app! What do you think?\";\n    await page.waitForSelector(`text=\"${firstPostTitle}\"`, { timeout: 5000 });\n\n    // Locate the first post's container by traversing up from the title node\n    const postContainerHandle = await page.$(`xpath=//h2[contains(., \"${firstPostTitle}\")]/ancestor::*[contains(@class, \"post\")]`);\n    let postContainer;\n    if (postContainerHandle) {\n      postContainer = postContainerHandle;\n    } else {\n      // fallback: try next parent if class is not available\n      const titleNode = await page.$(`text=\"${firstPostTitle}\"`);\n      postContainer = await titleNode.evaluateHandle(node => node.closest('article, .post, .post-container, .postCard') || node.parentElement);\n    }\n\n    // Take screenshot of the first post before saving\n    const step2 = path.join(screenshotsDir, 'step_2_before_save.png');\n    await page.screenshot({ path: step2 });\n    screenshots.push(step2);\n\n    // Find the \"Save\" button inside the first post\n    // Try multiple strategies: text, aria-label, button type, data attribute\n    // The Save button is usually labeled \"Save\" or has an icon with a label.\n    let saveButton = null;\n    // 1. Try text selector inside the post container\n    saveButton = await postContainer.$(`text=/^\\\\s*Save\\\\s*$/i`);\n    // 2. Try aria-label\n    if (!saveButton)\n      saveButton = await postContainer.$(`[aria-label=\"Save post\"]`);\n    // 3. Try button with icon (fallback)\n    if (!saveButton)\n      saveButton = await postContainer.$('button:has(svg[aria-label*=\"Save\"])');\n    // 4. Try first button with 'save' in aria-label or title\n    if (!saveButton)\n      saveButton = await postContainer.$('button[aria-label*=\"Save i\"],button[title*=\"Save\"]');\n    // 5. As last resort, find all buttons and pick the first with \"Save\" text\n    if (!saveButton) {\n      const buttons = await postContainer.$$('button');\n      for (const btn of buttons) {\n        const text = (await btn.innerText()).trim().toLowerCase();\n        if (text === 'save') {\n          saveButton = btn;\n          break;\n        }\n      }\n    }\n    if (!saveButton) {\n      throw new Error(\"Could not find the Save button for the first post\");\n    }\n\n    // Click the Save button\n    await saveButton.click();\n\n    // Wait for the Save button to update (e.g., to \"Saved\" or style changes)\n    // Try to wait for the button to change text to \"Saved\"\n    await page.waitForTimeout(500); // allow for UI update\n\n    // Try to re-select the Save button (it may have changed DOM or text)\n    let savedButton = await postContainer.$(`text=/^\\\\s*Saved\\\\s*$/i`);\n    if (!savedButton) {\n      // Sometimes the button changes style or gets a different aria-label\n      savedButton = await postContainer.$('[aria-label*=\"Saved\"]');\n    }\n    // If still not found, check if the original button text changed\n    let savedState = false;\n    if (savedButton) {\n      savedState = true;\n    } else {\n      const btnText = (await saveButton.innerText()).trim().toLowerCase();\n      if (btnText === 'saved') {\n        savedState = true;\n      }\n    }\n\n    // Take screenshot after saving\n    const step3 = path.join(screenshotsDir, 'step_3_after_save.png');\n    await page.screenshot({ path: step3 });\n    screenshots.push(step3);\n\n    // Extract data for verification\n    const extractedData = {\n      firstPostTitle,\n      savedState,\n      saveButtonText: savedState\n        ? 'Saved'\n        : (await saveButton.innerText()).trim()\n    };\n\n    return {\n      success: savedState,\n      action: \"Clicked save on the first post and verified it is marked as saved\",\n      extractedData,\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 27272,
      "timestamp": "2025-09-15T12:11:59.439Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Wait for the main feed container to load by main content region\n    // Try to identify the post list by role or structure\n    // Use a generic approach since the HTML structure is not fully visible\n    // We'll look for the first post card by using an XPath targeting the first article (if present), or first post container\n\n    // Wait for any post to appear (assume post containers have [data-post-id] or a certain class)\n    // We'll try to find a post with a button with a save icon or text \"Save\"\n    // Since we don't have the exact HTML for posts, let's use a flexible approach:\n    // 1. Find all visible buttons with text \"Save\" (case-insensitive)\n    // 2. Click the first one\n\n    // Wait for at least one Save button to appear\n    const saveButton = await page.waitForSelector('button:has-text(\"Save\"), button:has-text(\"save\"), button[aria-label=\"Save\"]', { timeout: 5000 });\n\n    // Take screenshot before clicking Save\n    const beforeSaveShot = path.join(screenshotsDir, 'step_2_before_save.png');\n    await page.screenshot({ path: beforeSaveShot });\n    screenshots.push(beforeSaveShot);\n\n    // Click the first Save button found\n    await saveButton.click();\n\n    // Wait for the button to indicate \"Saved\" state (e.g., text changes to \"Saved\", aria-pressed, or class changes)\n    // Try to wait for a button with text \"Saved\" that is visible and near the same location\n    // Use a flexible locator approach\n    await page.waitForTimeout(500); // Small wait for UI update\n\n    // Find button with text \"Saved\"\n    const savedButton = await page.waitForSelector('button:has-text(\"Saved\"), button:has-text(\"saved\"), button[aria-label=\"Saved\"], button[aria-pressed=\"true\"]', { timeout: 2000 });\n\n    // Take screenshot after saving\n    const afterSaveShot = path.join(screenshotsDir, 'step_3_after_save.png');\n    await page.screenshot({ path: afterSaveShot });\n    screenshots.push(afterSaveShot);\n\n    // Extract info to verify\n    let isSaved = false;\n    if (savedButton) {\n      // Check the button text\n      const savedText = (await savedButton.textContent()) || \"\";\n      isSaved = /saved/i.test(savedText.trim());\n    }\n\n    return {\n      success: isSaved,\n      action: \"Clicked the Save button on the first post and verified it is marked as saved\",\n      extractedData: {\n        savedButtonText: isSaved ? (await savedButton.textContent()).trim() : null\n      },\n      screenshots,\n      error: isSaved ? null : \"Save verification failed\"\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 15503,
      "timestamp": "2025-09-15T12:12:26.711Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 80003,
  "timestamp": "2025-09-15T12:11:22.211Z",
  "savedAt": "2025-09-15T12:12:42.214Z",
  "version": "1.0"
}