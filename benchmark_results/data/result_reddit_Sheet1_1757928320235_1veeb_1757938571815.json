{
  "id": "reddit_Sheet1_1757928320235_1veeb_1757938571815",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320235_1veeb",
    "description": 12,
    "objective": "Regular",
    "expectedResult": "Test keyboard navigation",
    "difficulty": "Medium",
    "category": "Use Tab key to navigate through interactive elements and verify focus",
    "tags": [
      "focusable elements [tabindex] [role]"
    ],
    "notes": "setupKeyboardNavigation()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Focus body to start keyboard navigation\n    await page.focus('body');\n\n    // Store the order of interactive elements as we tab through\n    const focusedElements = [];\n    const focusOrderSelectors = [\n      '#searchInput', // Search bar input\n      'button.theme-toggle-btn', // Theme toggle\n      'button.create-post-btn', // Create button\n      // Sidebar community buttons (first 4)\n      'button.community-link:has-text(\"programming\")',\n      'button.community-link:has-text(\"webdev\")',\n      'button.community-link:has-text(\"javascript\")',\n      'button.community-link:has-text(\"reactjs\")',\n      // Quick action buttons (View Profile, Create Post, Saved Posts)\n      'button.quick-action-btn:has-text(\"View Profile\")',\n      'button.quick-action-btn:has-text(\"Create Post\")',\n      'button.quick-action-btn:has-text(\"Saved Posts\")',\n      // Post form: community select, post title input\n      '#postCommunity',\n      '#postTitle'\n    ];\n\n    // Helper to get the currently focused element's selector or description\n    async function getFocusedElementInfo() {\n      return await page.evaluate(() => {\n        const el = document.activeElement;\n        if (!el) return null;\n        // Try to get a unique selector or description\n        if (el.id) return `#${el.id}`;\n        if (el.className && typeof el.className === 'string') {\n          // If multiple classes, just take the first\n          const className = el.className.split(' ')[0];\n          return `.${className}`;\n        }\n        if (el.tagName === 'BUTTON' && el.innerText.trim()) {\n          return `button: \"${el.innerText.trim()}\"`;\n        }\n        if (el.tagName === 'INPUT' && el.placeholder) {\n          return `input[placeholder=\"${el.placeholder}\"]`;\n        }\n        if (el.tagName === 'SELECT') {\n          return 'select';\n        }\n        return el.tagName;\n      });\n    }\n\n    // Focus the body to ensure tab starts from the top\n    await page.focus('body');\n\n    // Tab through the main interactive elements, recording focus order and taking screenshots\n    let tabCount = 0;\n    let foundSelectors = [];\n    let maxTabs = 15; // Safety to prevent infinite loop\n\n    for (let i = 0; i < maxTabs; i++) {\n      // Press Tab\n      await page.keyboard.press('Tab');\n      tabCount++;\n\n      // Wait a short time for focus to update\n      await page.waitForTimeout(200);\n\n      // Get info about the focused element\n      const focusedInfo = await getFocusedElementInfo();\n      focusedElements.push(focusedInfo);\n\n      // Take screenshot for each focus step\n      const screenshotPath = path.join(screenshotsDir, `step_${tabCount}_focus.png`);\n      await page.screenshot({ path: screenshotPath });\n      screenshots.push(screenshotPath);\n\n      // Try to match against our expected selectors for verification\n      for (let sel of focusOrderSelectors) {\n        // Use Playwright's locator to check if this element is focused\n        const isFocused = await page.evaluate((selector) => {\n          const el = document.activeElement;\n          if (!el) return false;\n          // Try querySelector for id/class\n          try {\n            if (selector.startsWith('#') || selector.startsWith('.')) {\n              return el.matches(selector);\n            }\n            // For :has-text, check innerText\n            if (selector.includes(':has-text(')) {\n              const [baseSel, textPart] = selector.split(':has-text(');\n              const text = textPart.replace(')', '').replace(/\"/g, '');\n              if (el.matches(baseSel.trim()) && el.innerText && el.innerText.includes(text)) {\n                return true;\n              }\n            }\n            return false;\n          } catch {\n            return false;\n          }\n        }, sel);\n\n        if (isFocused && !foundSelectors.includes(sel)) {\n          foundSelectors.push(sel);\n        }\n      }\n\n      // Stop if we've focused all expected elements\n      if (foundSelectors.length === focusOrderSelectors.length) break;\n    }\n\n    // Extracted data: list of focused elements and which selectors were found in order\n    const extractedData = {\n      focusOrder: focusedElements,\n      matchedSelectors: foundSelectors\n    };\n\n    return {\n      success: true,\n      action: \"Tested keyboard navigation using Tab key through interactive elements and verified focus order. Screenshots taken at each step.\",\n      extractedData,\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 32426,
      "timestamp": "2025-09-15T12:16:11.815Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Focus body to ensure keyboard navigation starts from top\n    await page.evaluate(() => document.body.focus());\n\n    // Wait for main interactive elements to be visible\n    await page.waitForSelector('input[placeholder=\"Search Reddit\"]');\n    await page.waitForSelector('button.theme-toggle-btn');\n    await page.waitForSelector('button.create-post-btn');\n    await page.waitForSelector('button.community-link');\n    await page.waitForSelector('#postCommunity');\n    await page.waitForSelector('input[placeholder=\"An interesting title\"]');\n\n    // TAB navigation order: \n    // 1. Search input\n    // 2. Theme toggle button\n    // 3. Create button\n    // 4. Community buttons (several)\n    // 5. Form fields\n\n    // Helper to get the currently-focused element's details\n    async function getFocusInfo() {\n      return await page.evaluate(() => {\n        if (!document.activeElement) return { tag: null, id: null, class: null, placeholder: null, aria: null, text: null };\n        return {\n          tag: document.activeElement.tagName,\n          id: document.activeElement.id,\n          class: document.activeElement.className,\n          placeholder: document.activeElement.placeholder || null,\n          aria: document.activeElement.getAttribute('aria-label') || null,\n          text: document.activeElement.textContent ? document.activeElement.textContent.trim() : null,\n          name: document.activeElement.getAttribute('name') || null\n        };\n      });\n    }\n\n    // Store the focus history for verification\n    const focusHistory = [];\n\n    // 1st TAB: Should focus the search input (placeholder=\"Search Reddit\")\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    let info = await getFocusInfo();\n    focusHistory.push(info);\n    // Screenshot after first TAB\n    const shot2 = path.join(screenshotsDir, 'step_2_search_focus.png');\n    await page.screenshot({ path: shot2 });\n    screenshots.push(shot2);\n\n    // 2nd TAB: Theme toggle button\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n    const shot3 = path.join(screenshotsDir, 'step_3_theme_toggle_focus.png');\n    await page.screenshot({ path: shot3 });\n    screenshots.push(shot3);\n\n    // 3rd TAB: \"Create\" button\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n    const shot4 = path.join(screenshotsDir, 'step_4_create_button_focus.png');\n    await page.screenshot({ path: shot4 });\n    screenshots.push(shot4);\n\n    // 4th TAB: First community button (programming)\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n    const shot5 = path.join(screenshotsDir, 'step_5_community1_focus.png');\n    await page.screenshot({ path: shot5 });\n    screenshots.push(shot5);\n\n    // 5th TAB: Second community button (webdev)\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n\n    // 6th TAB: Third community button (javascript)\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n\n    // 7th TAB: Fourth community button (reactjs)\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n\n    // 8th TAB: View Profile quick-action\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n\n    // 9th TAB: Create Post quick-action\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n\n    // 10th TAB: Saved Posts quick-action\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n\n    // 11th TAB: Post Community select dropdown\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n\n    // 12th TAB: Post Title input\n    await page.keyboard.press('Tab');\n    await page.waitForTimeout(300);\n    info = await getFocusInfo();\n    focusHistory.push(info);\n    const shot6 = path.join(screenshotsDir, 'step_6_post_title_focus.png');\n    await page.screenshot({ path: shot6 });\n    screenshots.push(shot6);\n\n    // Extracted data: Tag, class, aria-label/placeholder/text for each focusable element in order\n    const extractedData = {\n      focusOrder: focusHistory.map((el, i) => ({\n        step: i + 1,\n        tag: el.tag,\n        id: el.id,\n        class: el.class,\n        placeholder: el.placeholder,\n        aria: el.aria,\n        text: el.text,\n        name: el.name\n      }))\n    };\n\n    return {\n      success: true,\n      action: \"Tested keyboard TAB navigation through interactive elements and verified focus order and element details.\",\n      extractedData,\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 21888,
      "timestamp": "2025-09-15T12:16:44.241Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const step1 = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: step1 });\n    screenshots.push(step1);\n\n    // Focus on body to ensure tabbing starts from root\n    await page.focus('body');\n\n    // Store the order of focused elements as we tab through them\n    const focusOrder = [];\n    let lastActive = null;\n\n    // Helper to extract element description\n    async function describeFocused() {\n      return await page.evaluate(() => {\n        const el = document.activeElement;\n        if (!el) return null;\n        if (el.id) return `#${el.id}`;\n        if (el.className) return `.${el.className}`;\n        if (el.getAttribute('aria-label')) return `[aria-label=\"${el.getAttribute('aria-label')}\"]`;\n        if (el.tagName === 'BUTTON' && el.innerText.trim()) return `button:\"${el.innerText.trim()}\"`;\n        if (el.tagName === 'INPUT' && el.placeholder) return `input[placeholder=\"${el.placeholder}\"]`;\n        if (el.tagName === 'SELECT') return `select`;\n        return el.tagName;\n      });\n    }\n\n    // We'll Tab up to 12 times or until we've looped through at least 8 unique interactive elements\n    let uniqueElements = new Set();\n    for (let i = 0; i < 12; ++i) {\n      // Press Tab (first tab brings focus to first tabbable element)\n      await page.keyboard.press('Tab');\n      await page.waitForTimeout(150);\n\n      const desc = await describeFocused();\n      if (desc && !uniqueElements.has(desc)) {\n        uniqueElements.add(desc);\n        focusOrder.push(desc);\n\n        // Screenshot each newly focused element\n        const fname = `step_focus_${i + 1}_${desc.replace(/[^a-zA-Z0-9]/g, '_').slice(0,30)}.png`;\n        const shotPath = path.join(screenshotsDir, fname);\n        await page.screenshot({ path: shotPath });\n        screenshots.push(shotPath);\n\n        // Stop early if we loop back to the first element (cycle detected)\n        if (focusOrder.length > 1 && desc === focusOrder[0]) break;\n      }\n    }\n\n    // Extract info about the first 8 focused elements\n    const extractedData = { focusOrder: Array.from(uniqueElements).slice(0, 8) };\n\n    return {\n      success: true,\n      action: \"Tested keyboard navigation using Tab through interactive elements and recorded focus order\",\n      extractedData,\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 16426,
      "timestamp": "2025-09-15T12:17:06.129Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 70740,
  "timestamp": "2025-09-15T12:16:11.815Z",
  "savedAt": "2025-09-15T12:17:22.555Z",
  "version": "1.0"
}