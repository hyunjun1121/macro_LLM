{
  "id": "Threads_Sheet1_1757928320253_wvv58_1757934842873",
  "website": "Threads",
  "task": {
    "id": "Sheet1_1757928320253_wvv58",
    "description": "M002",
    "objective": "Rapidly Click Like Buttons",
    "expectedResult": "Click like buttons on all visible threads in rapid succession (within 5 seconds)",
    "difficulty": ".thread-action[data-action='like']",
    "category": 3,
    "tags": [
      "10 seconds"
    ],
    "notes": "Yes"
  },
  "websiteInfo": {
    "name": "Threads",
    "htmlFiles": [
      "index.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the threads feed to be visible\n    await page.waitForSelector('#threads-feed', { timeout: 5000 });\n\n    // Wait for at least one like button to be present\n    await page.waitForSelector(\".thread-action[data-action='like']\", { timeout: 5000 });\n\n    // Get all visible like buttons (not already liked)\n    const likeButtons = await page.$$eval(\n      \".thread-action[data-action='like']\",\n      (nodes) =>\n        nodes\n          .filter(\n            (btn) =>\n              btn.offsetParent !== null &&\n              !btn.classList.contains('liked') &&\n              !btn.disabled\n          )\n          .map((btn) => {\n            // Try to get a unique selector for each button\n            return {\n              xpath: btn.ownerDocument.evaluate(\n                'ancestor-or-self::*[@id][1]',\n                btn,\n                null,\n                XPathResult.FIRST_ORDERED_NODE_TYPE,\n                null\n              ).singleNodeValue\n                ? '//*[@id=\"' +\n                  btn.ownerDocument.evaluate(\n                    'ancestor-or-self::*[@id][1]',\n                    btn,\n                    null,\n                    XPathResult.FIRST_ORDERED_NODE_TYPE,\n                    null\n                  ).singleNodeValue.id +\n                  '\"]//button[contains(@class,\"thread-action\") and @data-action=\"like\"]'\n                : null,\n              index: Array.prototype.indexOf.call(\n                document.querySelectorAll(\".thread-action[data-action='like']\"),\n                btn\n              ),\n            };\n          })\n    );\n\n    // Fallback: If no unique xpath, use index\n    let clickedCount = 0;\n    const clickStart = Date.now();\n\n    for (let i = 0; i < likeButtons.length; ++i) {\n      // Try to click by xpath if available, else by nth-of-type\n      let clicked = false;\n      if (likeButtons[i].xpath) {\n        try {\n          const [el] = await page.$x(likeButtons[i].xpath);\n          if (el) {\n            await el.click({ timeout: 1000 });\n            clicked = true;\n          }\n        } catch (e) {}\n      }\n      if (!clicked) {\n        // Fallback: click by index among all visible like buttons\n        const btns = await page.$$(\n          \".thread-action[data-action='like']:not(.liked):not([disabled])\"\n        );\n        if (btns[i]) {\n          await btns[i].click({ timeout: 1000 });\n          clicked = true;\n        }\n      }\n      if (clicked) {\n        clickedCount++;\n      }\n      // If 5 seconds have passed, break\n      if (Date.now() - clickStart > 5000) break;\n    }\n\n    // Wait a moment for UI to update\n    await page.waitForTimeout(500);\n\n    // Take screenshot after liking\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_likes.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_likes.png'));\n\n    // Extract data: count of liked buttons (now with .liked class)\n    const likedCount = await page.$$eval(\n      \".thread-action[data-action='like'].liked\",\n      (nodes) => nodes.length\n    );\n\n    return {\n      success: true,\n      action: `Clicked like buttons on all visible threads in rapid succession (clicked ${clickedCount} in â‰¤5s)`,\n      extractedData: {\n        likedButtonsAfter: likedCount,\n        attemptedClicks: clickedCount\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 22052,
      "timestamp": "2025-09-15T11:14:02.873Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the main content area to be visible\n    await page.waitForSelector('main.main-content', { timeout: 5000 });\n\n    // Wait for threads to load by looking for at least one thread action button\n    // Try to locate like buttons using a different selector strategy:\n    // - Use a CSS selector that matches the button: .thread-action[data-action=\"like\"]\n    // - If not found, try an XPath alternative based on the text or icon\n\n    // Give the feed some time in case of dynamic loading\n    await page.waitForTimeout(500);\n\n    // Try to get all visible like buttons (not just in DOM, but visible on screen)\n    // Defensive: first try the CSS selector, then check alternatives if needed\n    let likeButtons = await page.$$('.thread-action[data-action=\"like\"]:not(.liked)');\n    if (likeButtons.length === 0) {\n      // Fallback: try to find buttons with aria-label or title containing 'Like'\n      likeButtons = await page.$$(`button[aria-label*=\"Like\"]:not(.liked), button[title*=\"Like\"]:not(.liked)`);\n    }\n    if (likeButtons.length === 0) {\n      // Fallback: try XPath for i.fa-heart inside a button\n      likeButtons = await page.$$('button:has(i.fa-heart):not(.liked)');\n    }\n\n    // Filter only those visible in the viewport\n    const visibleLikeButtons = [];\n    for (const btn of likeButtons) {\n      if (await btn.isVisible()) {\n        visibleLikeButtons.push(btn);\n      }\n    }\n\n    // Click all visible like buttons in rapid succession (within 5 seconds)\n    const clickStart = Date.now();\n    let clickedLikeCount = 0;\n    for (const btn of visibleLikeButtons) {\n      try {\n        await btn.click({ timeout: 200, force: true });\n        clickedLikeCount++;\n      } catch (err) {\n        // Ignore click errors for individual buttons\n      }\n      // Optional: small delay between clicks to avoid UI glitches\n      await page.waitForTimeout(50);\n      if (Date.now() - clickStart > 5000) break; // Enforce 5 seconds\n    }\n\n    // Wait for UI to update likes (in case there's an animation)\n    await page.waitForTimeout(500);\n\n    // Screenshot after liking\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_after_likes.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_after_likes.png'));\n\n    // Extract data: list of thread IDs or count of liked threads\n    // Try to find all now-liked buttons in the viewport\n    const likedNow = await page.$$eval(\n      '.thread-action[data-action=\"like\"].liked, button.liked[aria-label*=\"Like\"], button.liked[title*=\"Like\"]',\n      nodes => nodes.filter(\n        node => node.offsetParent !== null // visible\n      ).length\n    );\n\n    return {\n      success: true,\n      action: `Clicked 'like' buttons on all visible threads in rapid succession (${clickedLikeCount} attempted, ${likedNow} now show as liked)`,\n      extractedData: {\n        attemptedLikes: clickedLikeCount,\n        visibleThreadsNowLiked: likedNow\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 26222,
      "timestamp": "2025-09-15T11:14:24.925Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Wait for the threads feed to be present in DOM\n    await page.waitForSelector('#threads-feed', { timeout: 5000 });\n\n    // Wait for at least one thread like button to be visible\n    // Try different selector strategies (button, aria, xpath)\n    let likeButtons = await page.$$('.thread-action[data-action=\"like\"]');\n    if (!likeButtons.length) {\n      // Try by text content fallback (in case data-action attr is not present)\n      likeButtons = await page.$$('button:has([class*=\"fa-heart\"])');\n    }\n    if (!likeButtons.length) {\n      // Try xpath as last resort\n      likeButtons = await page.$x(\"//button[contains(@class,'thread-action') and @data-action='like']\");\n    }\n\n    // Wait for at least one like button to appear\n    if (likeButtons.length === 0) {\n      await page.waitForSelector('.thread-action[data-action=\"like\"]', { timeout: 4000 });\n      likeButtons = await page.$$('.thread-action[data-action=\"like\"]');\n    }\n\n    // Filter only visible buttons\n    const visibleLikeButtons = [];\n    for (const btn of likeButtons) {\n      if (await btn.isVisible()) {\n        visibleLikeButtons.push(btn);\n      }\n    }\n\n    if (visibleLikeButtons.length === 0) {\n      throw new Error('No visible like buttons found.');\n    }\n\n    // Click all like buttons in rapid succession (within 5 seconds)\n    const clickPromises = [];\n    const likeBtnHandles = [];\n    for (const btn of visibleLikeButtons) {\n      likeBtnHandles.push(btn);\n    }\n    // Start timer\n    const clickStart = Date.now();\n    for (const btn of likeBtnHandles) {\n      clickPromises.push(btn.click());\n    }\n    await Promise.all(clickPromises);\n    const clickDuration = Date.now() - clickStart;\n\n    // Wait a short moment to allow UI to update after likes\n    await page.waitForTimeout(800);\n\n    // Screenshot after likes\n    const afterLikeShot = path.join(screenshotsDir, 'step_2_after_likes.png');\n    await page.screenshot({ path: afterLikeShot });\n    screenshots.push(afterLikeShot);\n\n    // Extract data: count number of liked buttons (assume 'liked' toggles a class, e.g. 'liked' or aria-pressed, or color)\n    // Try to detect visually toggled state\n    let likedCount = 0;\n    for (const btn of likeBtnHandles) {\n      const className = await btn.getAttribute('class') || '';\n      const ariaPressed = await btn.getAttribute('aria-pressed');\n      if (className.includes('liked') || ariaPressed === 'true') {\n        likedCount++;\n      } else {\n        // Try: check if the icon color changed (e.g. fa-solid or style)\n        const heartIcon = await btn.$('i.fa-heart');\n        if (heartIcon) {\n          const iconClass = await heartIcon.getAttribute('class') || '';\n          if (iconClass.includes('fa-solid')) {\n            likedCount++;\n          } else {\n            // Optionally, check computed style (but may not be necessary)\n            // const color = await heartIcon.evaluate(el => getComputedStyle(el).color);\n          }\n        }\n      }\n    }\n\n    return {\n      success: true,\n      action: `Clicked like buttons on all visible threads (${likeBtnHandles.length}) in rapid succession (${clickDuration} ms)`,\n      extractedData: {\n        visibleLikeButtons: likeBtnHandles.length,\n        likedButtonsDetected: likedCount,\n        clickDurationMs: clickDuration\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 29569,
      "timestamp": "2025-09-15T11:14:51.147Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 77843,
  "timestamp": "2025-09-15T11:14:02.873Z",
  "savedAt": "2025-09-15T11:15:20.716Z",
  "version": "1.0"
}