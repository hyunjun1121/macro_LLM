{
  "id": "reddit_Sheet1_1757928320235_yb714_1757938282457",
  "website": "reddit",
  "task": {
    "id": "Sheet1_1757928320235_yb714",
    "description": 8,
    "objective": "Regular",
    "expectedResult": "Save first post",
    "difficulty": "Easy",
    "category": "Click save button on first post and verify it's marked as saved",
    "tags": [
      ".post:first-child .post-action.saved"
    ],
    "notes": "toggleSavePost() saveDataToStorage()"
  },
  "websiteInfo": {
    "name": "reddit",
    "htmlFiles": [
      "community.html",
      "index.html",
      "profile.html"
    ],
    "hasIndex": true,
    "structure": {}
  },
  "attempts": [
    {
      "attemptNumber": 1,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_1_initial.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_1_initial.png'));\n\n    // Wait for the posts container to load (main feed)\n    // Try to find the first post's Save button\n    // We'll use a combination of text and button selectors\n\n    // Wait for the post list to appear (look for a post title)\n    const firstPostTitleSelector = 'article .post-title, .post-title, [class*=post-title], h3, h2';\n    await page.waitForSelector(firstPostTitleSelector, { timeout: 5000 });\n\n    // Find the first post container (assuming posts are in <article> or similar)\n    // We'll try to get the first post's container by looking for a post title, then navigating up\n    const firstPostHandle = await page.$x(\n      // Try to find the first post title and get its ancestor article/div\n      `//*[contains(@class, 'post-title') or self::h3 or self::h2][1]/ancestor::article | //*[contains(@class, 'post-title') or self::h3 or self::h2][1]/ancestor::div[contains(@class, 'post')]`\n    );\n    let postContainer = null;\n    if (firstPostHandle.length > 0) {\n      postContainer = firstPostHandle[0];\n    } else {\n      // fallback: select first article or div with post class\n      postContainer = await page.$('article') || await page.$('div[class*=post]');\n    }\n\n    if (!postContainer) {\n      throw new Error('Could not locate the first post container');\n    }\n\n    // Look for the Save button inside the post container\n    // Try common selectors: button with text \"Save\", aria-label, or save icon\n    let saveButton = await postContainer.$('button:has-text(\"Save\")');\n    if (!saveButton) {\n      // Try by aria-label\n      saveButton = await postContainer.$('button[aria-label*=\"Save\"], button[title*=\"Save\"]');\n    }\n    if (!saveButton) {\n      // Try by icon (FontAwesome or SVG)\n      saveButton = await postContainer.$('button:has(i.fa-bookmark), button:has(svg[aria-label*=\"Save\"])');\n    }\n    if (!saveButton) {\n      // Try any button that looks like a save (as a last resort, get all buttons and pick the first)\n      const buttons = await postContainer.$$('button');\n      if (buttons.length > 0) saveButton = buttons[buttons.length - 1]; // Often save is last\n    }\n\n    if (!saveButton) {\n      throw new Error('Could not locate the Save button on the first post');\n    }\n\n    // Take screenshot before clicking Save\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_2_before_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_2_before_save.png'));\n\n    // Click the Save button\n    await saveButton.click();\n\n    // Wait for the Save button to change state (e.g., text changes to \"Saved\" or icon changes)\n    // We'll poll for a button with text \"Saved\" or aria-pressed=true\n    let savedState = false;\n    for (let i = 0; i < 10; i++) {\n      // Try to find a \"Saved\" button inside the same post\n      const savedBtn = await postContainer.$('button:has-text(\"Saved\")');\n      if (savedBtn) {\n        savedState = true;\n        break;\n      }\n      // Try aria-pressed or aria-label\n      const ariaPressed = await postContainer.$('button[aria-pressed=\"true\"], button[aria-label*=\"Saved\"]');\n      if (ariaPressed) {\n        savedState = true;\n        break;\n      }\n      // Try icon change (e.g., fa-bookmark filled)\n      const filledBookmark = await postContainer.$('button:has(i.fa-bookmark), button:has(svg[aria-label*=\"Saved\"])');\n      if (filledBookmark) {\n        // Optionally check if icon has a filled class\n        const className = await filledBookmark.getAttribute('class');\n        if (className && className.includes('filled')) {\n          savedState = true;\n          break;\n        }\n      }\n      await page.waitForTimeout(300);\n    }\n\n    // Take screenshot after saving\n    await page.screenshot({ path: path.join(screenshotsDir, 'step_3_after_save.png') });\n    screenshots.push(path.join(screenshotsDir, 'step_3_after_save.png'));\n\n    // Extract the post title and saved state for verification\n    let postTitle = await postContainer.$eval(\n      '.post-title, h3, h2',\n      el => el.innerText.trim()\n    ).catch(() => null);\n\n    // If not found, try a generic selector\n    if (!postTitle) {\n      postTitle = await postContainer.evaluate(el => {\n        const h3 = el.querySelector('h3');\n        if (h3) return h3.innerText.trim();\n        const h2 = el.querySelector('h2');\n        if (h2) return h2.innerText.trim();\n        return null;\n      });\n    }\n\n    return {\n      success: savedState,\n      action: savedState\n        ? \"Clicked save on first post and verified it is marked as saved\"\n        : \"Clicked save on first post but could not verify saved state\",\n      extractedData: {\n        firstPostTitle: postTitle,\n        savedState\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 32258,
      "timestamp": "2025-09-15T12:11:22.457Z"
    },
    {
      "attemptNumber": 2,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  const screenshots = [];\n  try {\n    // Step 1: Navigate to the HTML file and wait for page to load\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Step 2: Initial screenshot\n    const initialShot = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: initialShot });\n    screenshots.push(initialShot);\n\n    // Step 3: Locate the first post card using an attribute unique to posts\n    // We'll try to locate by text content and structure, as IDs/classes are not visible in initial info\n    // Try a generic post container: find the first post by a unique string in the post (title)\n    // The first post title (from JS): \"Just built my first React app! What do you think?\"\n\n    const firstPostTitle = 'Just built my first React app! What do you think?';\n    const postTitleSelector = `text=\"${firstPostTitle}\"`;\n\n    await page.waitForSelector(postTitleSelector, { timeout: 5000 });\n    // Get the parent post container (assume it's 2 levels up)\n    const postContainer = await page.locator(postTitleSelector).locator('..').locator('..').first();\n\n    // Step 4: Find the Save button within the first post\n    // Since the HTML and JS don't provide a clear selector, use button text or aria-label\n    // Try to find a button with text \"Save\" inside the post card\n    const saveButton = await postContainer.locator('button:has-text(\"Save\")');\n    await saveButton.waitFor({ state: 'visible', timeout: 3000 });\n\n    // Step 5: Take screenshot before clicking Save\n    const beforeSaveShot = path.join(screenshotsDir, 'step_2_before_save.png');\n    await page.screenshot({ path: beforeSaveShot });\n    screenshots.push(beforeSaveShot);\n\n    // Step 6: Click the Save button\n    await saveButton.click();\n\n    // Step 7: Wait for the Save button to change state (e.g., text changes to \"Saved\" or aria-pressed, etc)\n    // Try to wait for the button text to become \"Saved\"\n    const savedButton = await postContainer.locator('button:has-text(\"Saved\")');\n    await savedButton.waitFor({ state: 'visible', timeout: 3000 });\n\n    // Step 8: Take screenshot after saving\n    const afterSaveShot = path.join(screenshotsDir, 'step_3_after_save.png');\n    await page.screenshot({ path: afterSaveShot });\n    screenshots.push(afterSaveShot);\n\n    // Step 9: Extract state for verification\n    const savedButtonText = await savedButton.textContent();\n    const isSaved = savedButtonText && savedButtonText.toLowerCase().includes('saved');\n\n    return {\n      success: isSaved,\n      action: isSaved\n        ? 'Clicked Save on the first post and verified it is marked as saved'\n        : 'Clicked Save but did not verify the post was marked as saved',\n      extractedData: {\n        firstPostTitle,\n        saveButtonText: savedButtonText,\n        isSaved\n      },\n      screenshots,\n      error: null\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots,\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 15817,
      "timestamp": "2025-09-15T12:11:54.715Z"
    },
    {
      "attemptNumber": 3,
      "model": "openai/gpt-4.1",
      "macroCode": "import path from 'path';\n\nexport default async function(page, fileUrl, screenshotsDir) {\n  try {\n    // Navigate to the HTML file\n    await page.goto(fileUrl);\n    await page.waitForLoadState('networkidle');\n\n    // Take initial screenshot\n    const screenshots = [];\n    const step1 = path.join(screenshotsDir, 'step_1_initial.png');\n    await page.screenshot({ path: step1 });\n    screenshots.push(step1);\n\n    // Wait for posts list to appear using a robust selector: look for a post card via XPath for post title\n    // We'll try to find the first post's card by heading, assuming posts are rendered as articles or divs with the post title as an h2/h3\n    // Try alternative strategies for different possible DOMs\n\n    // Strategy 1: Find first post by locating the first large clickable \"Save\" or bookmark icon/text/button\n\n    // Wait for at least one post to be rendered (look for a post title)\n    const postTitleLocator = await page.waitForSelector('xpath=//div[contains(@class,\"post\") or contains(@class,\"Post\") or contains(@class,\"post-card\") or contains(@class,\"post-container\") or contains(@class, \"main-content\")]//h3 | //h2 | //div[contains(@class,\"post-title\")]', { timeout: 5000 });\n\n    // Find the parent post container from the title node\n    const postContainer = await postTitleLocator.evaluateHandle(el => {\n      // Traverse up to parent card-like div\n      let node = el;\n      for (let i = 0; i < 5; i++) {\n        if (node.parentElement && node.parentElement.querySelector('button, [role=\"button\"]')) {\n          return node.parentElement;\n        }\n        node = node.parentElement;\n      }\n      return el.parentElement;\n    });\n\n    // Now, within this post, look for a save button: \n    // Try several strategies, prefer aria-label, title, class, and icon\n    // 1. Button with aria-label \"Save\" or \"Save post\"\n    // 2. Button with a bookmark/star icon\n    // 3. Button with text \"Save\"\n\n    let saveButton = await postContainer.$('button[aria-label*=\"Save\" i]');\n    if (!saveButton) {\n      saveButton = await postContainer.$('button[title*=\"Save\" i]');\n    }\n    if (!saveButton) {\n      // Try button with text \"Save\"\n      saveButton = await postContainer.$('xpath=.//button[normalize-space(translate(text(),\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\"abcdefghijklmnopqrstuvwxyz\"))=\"save\"]');\n    }\n    if (!saveButton) {\n      // Try for a button with a bookmark/star icon\n      saveButton = await postContainer.$('button i.fas.fa-bookmark, button i.fa-bookmark, button i.fa-star');\n      if (saveButton) {\n        // Need to get the button, not the icon\n        saveButton = await saveButton.evaluateHandle(i => i.closest('button'));\n      }\n    }\n\n    if (!saveButton) {\n      throw new Error('Could not find save button on the first post');\n    }\n\n    // Take screenshot before clicking save\n    const step2 = path.join(screenshotsDir, 'step_2_before_save.png');\n    await page.screenshot({ path: step2 });\n    screenshots.push(step2);\n\n    // Click save button\n    await saveButton.click();\n\n    // Wait for visual feedback: e.g. button text changes to \"Saved\", aria-pressed changes, or icon changes\n    // Try several strategies\n    let savedState = false;\n    let savedText = '';\n    let saveButtonAfter = null;\n\n    // Wait for up to 2s for the button state to change\n    for (let i = 0; i < 10; i++) {\n      // Re-query the save button in case it re-renders\n      saveButtonAfter = await postContainer.$('button[aria-label*=\"Save\" i], button[title*=\"Save\" i], xpath=.//button');\n      if (saveButtonAfter) {\n        savedText = await saveButtonAfter.evaluate(btn => btn.innerText.trim().toLowerCase());\n        const ariaPressed = await saveButtonAfter.evaluate(btn => btn.getAttribute('aria-pressed'));\n        const classes = await saveButtonAfter.evaluate(btn => btn.className);\n\n        // Check if text changed to \"Saved\" or aria-pressed=\"true\" or class includes \"saved\"\n        if (savedText === 'saved' || ariaPressed === 'true' || (classes && classes.toLowerCase().includes('saved'))) {\n          savedState = true;\n          break;\n        }\n        // Sometimes text is \"Save\" but icon changes (e.g. solid bookmark)\n        // Check for icon change (fa-bookmark, fa-solid, etc)\n        const iconClass = await saveButtonAfter.$('i.fa-bookmark, i.fas.fa-bookmark, i.fa-solid');\n        if (iconClass) {\n          const iconClassName = await iconClass.evaluate(i => i.className);\n          if (iconClassName && (iconClassName.includes('fa-solid') || iconClassName.includes('fas'))) {\n            savedState = true;\n            break;\n          }\n        }\n      }\n      await page.waitForTimeout(200);\n    }\n\n    // Take screenshot after clicking save\n    const step3 = path.join(screenshotsDir, 'step_3_after_save.png');\n    await page.screenshot({ path: step3 });\n    screenshots.push(step3);\n\n    // Extract the post title for reporting\n    const postTitleText = await postTitleLocator.evaluate(el => el.innerText);\n\n    return {\n      success: savedState,\n      action: savedState\n        ? `Clicked save on the first post \"${postTitleText}\" and verified it is marked as saved`\n        : `Clicked save on the first post \"${postTitleText}\" but could not verify saved state`,\n      extractedData: {\n        postTitle: postTitleText,\n        savedState,\n        saveButtonText: savedText\n      },\n      screenshots,\n      error: savedState ? null : 'Failed to verify the post is marked as saved'\n    };\n  } catch (error) {\n    return {\n      success: false,\n      action: \"Failed to complete task\",\n      extractedData: {},\n      screenshots: [],\n      error: error.message\n    };\n  }\n}",
      "executionResult": null,
      "success": false,
      "error": "isServerMode is not defined",
      "executionTime": 44343,
      "timestamp": "2025-09-15T12:12:10.532Z"
    }
  ],
  "success": false,
  "finalResult": null,
  "totalExecutionTime": 92418,
  "timestamp": "2025-09-15T12:11:22.457Z",
  "savedAt": "2025-09-15T12:12:54.875Z",
  "version": "1.0"
}